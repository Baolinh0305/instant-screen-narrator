This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
build.rs
Cargo.toml
README.md
src/arrow.png
src/capture.rs
src/config.rs
src/icon2.ico
src/key_utils.rs
src/main.rs
src/overlay.rs
src/roboto.ttf
src/translation.rs
src/tts.rs
src/ui.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Rust build artifacts
target/

# Cargo.lock (optional, but often ignored for libraries)
# Cargo.lock

# IDE files
.vscode/
.idea/

# OS files
.DS_Store
Thumbs.db

# Logs
*.log

# Temporary files
*.tmp
*.swp
</file>

<file path="build.rs">
extern crate winres;

fn main() {
    if cfg!(target_os = "windows") {
        let mut res = winres::WindowsResource::new();
        
        // Ensure you have an icon file at src/icon2.ico or change this path
        res.set_icon("src/icon2.ico");
        
        res.set_manifest(r#"
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
<trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
        <requestedPrivileges>
            <requestedExecutionLevel level="requireAdministrator" uiAccess="false" />
        </requestedPrivileges>
    </security>
</trustInfo>
</assembly>
"#);

        res.compile().unwrap();
    }
}
</file>

<file path="Cargo.toml">
[package]
name = "screen_translator"
version = "0.1.0"
edition = "2021"

[build-dependencies]
winres = "0.1"

[dependencies]
eframe = "0.27"
reqwest = { version = "0.12", features = ["json"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1", features = ["full"] }
anyhow = "1.0"
webbrowser = "0.8"
screenshots = "0.8"
image = "0.24"
base64 = "0.22"
rodio = "0.19"
urlencoding = "2.1"
regex = "1.10"
global-hotkey = "0.5"
winapi = { version = "0.3", features = ["winuser", "libloaderapi", "shellapi", "wingdi", "windef", "minwindef", "errhandlingapi"] }
futures = "0.3"
rfd = "0.12"
arboard = "3.3"
tray-icon = "0.14"
</file>

<file path="README.md">
# Instant Screen Narrator

Đây là một ứng dụng dịch màn hình được viết bằng Rust. Ứng dụng cho phép chụp màn hình, dịch văn bản và phát âm thanh.

## Tính năng

- Chụp màn hình vùng chọn
- Dịch văn bản sang nhiều ngôn ngữ
- Phát âm thanh văn bản dịch

## Cách cài đặt

1. Đảm bảo bạn đã cài đặt Rust.
2. Clone repository này.
3. Chạy `cargo build --release` để biên dịch.

## Cách sử dụng

Tải file instant_screen_narrator.exe từ [releases](https://github.com/Baolinh0305/instant-screen-narrator/releases) và chạy.

## Giấy phép

Dự án này sử dụng giấy phép MIT.
</file>

<file path="src/key_utils.rs">
use winapi::um::winuser::*;

pub fn get_vk_from_name(name: &str) -> i32 {
    let name = name.to_uppercase();
    match name.as_str() {
        "F1" => VK_F1, "F2" => VK_F2, "F3" => VK_F3, "F4" => VK_F4,
        "F5" => VK_F5, "F6" => VK_F6, "F7" => VK_F7, "F8" => VK_F8,
        "F9" => VK_F9, "F10" => VK_F10, "F11" => VK_F11, "F12" => VK_F12,
        "SPACE" => VK_SPACE, "ENTER" => VK_RETURN, "TAB" => VK_TAB, "ESC" => VK_ESCAPE,
        "SHIFT" => VK_SHIFT, "CTRL" => VK_CONTROL, "ALT" => VK_MENU,
        "INSERT" => VK_INSERT, "DELETE" => VK_DELETE, "HOME" => VK_HOME, "END" => VK_END,
        "PAGEUP" => VK_PRIOR, "PAGEDOWN" => VK_NEXT,
        "UP" => VK_UP, "DOWN" => VK_DOWN, "LEFT" => VK_LEFT, "RIGHT" => VK_RIGHT,
        "[" => 0xDB, "]" => 0xDD, "\\" => 0xDC, ";" => 0xBA, "'" => 0xDE,
        "," => 0xBC, "." => 0xBE, "/" => 0xBF, "`" => 0xC0, "-" => 0xBD, "=" => 0xBB,
        _ => {
            if name.len() == 1 {
                let c = name.chars().next().unwrap();
                if c >= '0' && c <= '9' { return c as i32; }
                if c >= 'A' && c <= 'Z' { return c as i32; }
            }
            0
        }
    }
}

pub fn get_name_from_vk(vk: i32) -> String {
    match vk {
        VK_F1 => "F1".to_string(), VK_F2 => "F2".to_string(), VK_F3 => "F3".to_string(), VK_F4 => "F4".to_string(),
        VK_F5 => "F5".to_string(), VK_F6 => "F6".to_string(), VK_F7 => "F7".to_string(), VK_F8 => "F8".to_string(),
        VK_F9 => "F9".to_string(), VK_F10 => "F10".to_string(), VK_F11 => "F11".to_string(), VK_F12 => "F12".to_string(),
        VK_SPACE => "SPACE".to_string(), VK_RETURN => "ENTER".to_string(), VK_TAB => "TAB".to_string(), VK_ESCAPE => "ESC".to_string(),
        VK_SHIFT | VK_LSHIFT | VK_RSHIFT => "SHIFT".to_string(),
        VK_CONTROL | VK_LCONTROL | VK_RCONTROL => "CTRL".to_string(),
        VK_MENU | VK_LMENU | VK_RMENU => "ALT".to_string(),
        VK_INSERT => "INSERT".to_string(), VK_DELETE => "DELETE".to_string(), VK_HOME => "HOME".to_string(), VK_END => "END".to_string(),
        VK_PRIOR => "PAGEUP".to_string(), VK_NEXT => "PAGEDOWN".to_string(),
        VK_UP => "UP".to_string(), VK_DOWN => "DOWN".to_string(), VK_LEFT => "LEFT".to_string(), VK_RIGHT => "RIGHT".to_string(),
        0xDB => "[".to_string(), 0xDD => "]".to_string(), 0xDC => "\\".to_string(), 0xBA => ";".to_string(), 0xDE => "'".to_string(),
        0xBC => ",".to_string(), 0xBE => ".".to_string(), 0xBF => "/".to_string(), 0xC0 => "`".to_string(), 0xBD => "-".to_string(), 0xBB => "=".to_string(),
        _ => {
            if vk >= '0' as i32 && vk <= '9' as i32 { return ((vk as u8) as char).to_string(); }
            if vk >= 'A' as i32 && vk <= 'Z' as i32 { return ((vk as u8) as char).to_string(); }
            format!("KEY_{}", vk)
        }
    }
}
</file>

<file path="src/translation.rs">
use reqwest;
use serde::{Deserialize, Serialize};
use base64::{Engine as _, engine::general_purpose};
use anyhow::Result;

// --- STRUCTURES ---
#[derive(Serialize)]
struct GeminiRequest { contents: Vec<Content> }
#[derive(Serialize)]
struct Content { parts: Vec<Part> }
#[derive(Serialize)]
struct Part { text: Option<String>, inline_data: Option<InlineData> }
#[derive(Serialize)]
struct InlineData { mime_type: String, data: String }
#[derive(Deserialize)]
struct GeminiResponse { candidates: Vec<Candidate> }
#[derive(Deserialize)]
struct Candidate { content: ContentResponse }
#[derive(Deserialize)]
struct ContentResponse { parts: Vec<PartResponse> }
#[derive(Deserialize)]
struct PartResponse { text: String }

pub struct TranslationResult {
    pub text: String,
    pub remaining_requests: Option<i32>,
}

#[derive(Debug)]
pub enum TranslationError {
    RateLimitExceeded,
    Other(anyhow::Error),
}

// --- GEMINI ---
pub async fn translate_with_gemini_image(api_key: &str, prompt: &str, image_bytes: &[u8]) -> Result<TranslationResult, TranslationError> {
    let client = reqwest::Client::new();
    let b64 = general_purpose::STANDARD.encode(image_bytes);
    let request = GeminiRequest {
        contents: vec![Content {
            parts: vec![
                Part { text: Some(prompt.to_string()), inline_data: None },
                Part { text: None, inline_data: Some(InlineData { mime_type: "image/png".to_string(), data: b64 }) },
            ],
        }],
    };
    let url = format!("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key={}", api_key);
    
    let response = client.post(&url).header("Content-Type", "application/json").json(&request).send().await.map_err(|e| TranslationError::Other(e.into()))?;

    if !response.status().is_success() {
        let status = response.status();
        if status.as_u16() == 429 { return Err(TranslationError::RateLimitExceeded); }
        return Err(TranslationError::Other(anyhow::anyhow!("Gemini Error {}", status)));
    }

    let resp_json: GeminiResponse = response.json().await.map_err(|e| TranslationError::Other(e.into()))?;
    if resp_json.candidates.is_empty() { return Err(TranslationError::Other(anyhow::anyhow!("No candidates"))); }
    let text = resp_json.candidates[0].content.parts[0].text.trim().to_string();
    
    Ok(TranslationResult { text, remaining_requests: None })
}

// --- GROQ ---
pub async fn translate_with_groq_image(api_key: &str, prompt: &str, image_bytes: &[u8]) -> Result<TranslationResult, TranslationError> {
    let client = reqwest::Client::new();
    let b64 = general_purpose::STANDARD.encode(image_bytes);
    let request = serde_json::json!({
        "model": "meta-llama/llama-4-scout-17b-16e-instruct",
        "messages": [
            {
                "role": "user",
                "content": [
                    { "type": "text", "text": prompt },
                    { "type": "image_url", "image_url": { "url": format!("data:image/png;base64,{}", b64) } }
                ]
            }
        ],
        "temperature": 0.1
    });
    let url = "https://api.groq.com/openai/v1/chat/completions";
    
    let response = client.post(url)
        .header("Authorization", format!("Bearer {}", api_key))
        .header("Content-Type", "application/json")
        .json(&request)
        .send()
        .await
        .map_err(|e| TranslationError::Other(e.into()))?;

    let status = response.status();
    let remaining = response.headers().get("x-ratelimit-remaining-requests").and_then(|h| h.to_str().ok()).and_then(|s| s.parse::<i32>().ok());

    if !status.is_success() {
        if status.as_u16() == 429 { return Err(TranslationError::RateLimitExceeded); }
        let body = response.text().await.unwrap_or_default();
        return Err(TranslationError::Other(anyhow::anyhow!("Groq Error {}: {}", status, body)));
    }

    let resp_json: serde_json::Value = response.json().await.map_err(|e| TranslationError::Other(e.into()))?;
    
    if let Some(content) = resp_json["choices"][0]["message"]["content"].as_str() {
        Ok(TranslationResult { text: content.trim().to_string(), remaining_requests: remaining })
    } else {
        Err(TranslationError::Other(anyhow::anyhow!("Invalid Groq response")))
    }
}

pub async fn translate_from_image(api: &str, key: &str, prompt: &str, image_bytes: &[u8]) -> Result<TranslationResult, TranslationError> {
    match api {
        "gemini" => translate_with_gemini_image(key, prompt, image_bytes).await,
        "groq" => translate_with_groq_image(key, prompt, image_bytes).await,
        _ => Err(TranslationError::Other(anyhow::anyhow!("Invalid API"))),
    }
}
</file>

<file path="src/tts.rs">
use reqwest;
use rodio::{Decoder, OutputStream, Sink, Source};
use std::io::Cursor;
use regex::Regex;
use urlencoding;
use futures::future::join_all;
use std::sync::atomic::{AtomicBool, Ordering};

// Biến cờ để báo hiệu dừng đọc
static STOP_SIGNAL: AtomicBool = AtomicBool::new(false);

// Hàm gọi từ bên ngoài để dừng đọc
pub fn stop() {
    STOP_SIGNAL.store(true, Ordering::Relaxed);
}

pub async fn speak(text: &str, split: bool, speed: f32, use_tts: bool) -> Result<(), anyhow::Error> {
    if use_tts {
        // Reset cờ dừng trước khi bắt đầu câu mới
        STOP_SIGNAL.store(false, Ordering::Relaxed);
        speak_gtts(text, split, speed).await
    } else {
        Ok(())
    }
}

async fn speak_gtts(text: &str, split: bool, speed: f32) -> Result<(), anyhow::Error> {
    let parts: Vec<String> = if split {
        let re = Regex::new(r"[,.]")?;
        re.split(text).map(|s| s.to_string()).collect()
    } else {
        vec![text.to_string()]
    };

    // Tải song song tất cả các đoạn audio
    let (_stream, stream_handle) = OutputStream::try_default()?;
    let handles: Vec<_> = parts.into_iter().filter(|p| !p.trim().is_empty()).map(|part| {
        tokio::spawn(async move {
            let url = format!(
                "https://translate.google.com/translate_tts?ie=UTF-8&q={}&tl=vi&client=tw-ob",
                urlencoding::encode(&part.trim())
            );
            let response = reqwest::get(&url).await?;
            response.bytes().await
        })
    }).collect();

    let results = join_all(handles).await;

    for result in results {
        // Kiểm tra cờ dừng trước khi phát đoạn tiếp theo
        if STOP_SIGNAL.load(Ordering::Relaxed) {
            break;
        }

        let bytes = result??;
        let sink = Sink::try_new(&stream_handle)?;
        let cursor = Cursor::new(bytes);
        let source = Decoder::new_mp3(cursor)?;
        let sped_source = source.speed(speed);
        
        sink.append(sped_source);
        
        // Vòng lặp chờ audio chạy xong, nhưng có kiểm tra cờ dừng liên tục
        while !sink.empty() {
            if STOP_SIGNAL.load(Ordering::Relaxed) {
                sink.stop(); // Dừng ngay lập tức
                return Ok(());
            }
            // Ngủ ngắn để không chiếm CPU
            std::thread::sleep(std::time::Duration::from_millis(50));
        }
    }
    Ok(())
}

// 1. Chỉ tải dữ liệu
pub async fn download_audio(text: String) -> Result<Vec<u8>, anyhow::Error> {
    if text.trim().is_empty() { return Ok(Vec::new()); }
    let url = format!(
        "https://translate.google.com/translate_tts?ie=UTF-8&q={}&tl=vi&client=tw-ob",
        urlencoding::encode(&text.trim())
    );
    let response = reqwest::get(&url).await?;
    let bytes = response.bytes().await?;
    Ok(bytes.to_vec())
}

// 2. Phát dữ liệu (Blocking)
pub fn play_audio_data(data: Vec<u8>, speed: f32) -> Result<(), anyhow::Error> {
    if data.is_empty() { return Ok(()); }
    // Reset cờ trước khi phát
    STOP_SIGNAL.store(false, Ordering::Relaxed);

    let (_stream, stream_handle) = OutputStream::try_default()?;
    let sink = Sink::try_new(&stream_handle)?;
    let cursor = Cursor::new(data);
    let source = Decoder::new_mp3(cursor)?;
    let sped_source = source.speed(speed);
    
    sink.append(sped_source);
    
    while !sink.empty() {
        if STOP_SIGNAL.load(Ordering::Relaxed) {
            sink.stop();
            return Ok(());
        }
        std::thread::sleep(std::time::Duration::from_millis(50));
    }
    Ok(())
}
</file>

<file path="src/overlay.rs">
use winapi::shared::windef::{POINT, RECT, HWND, SIZE, HBITMAP};
use winapi::shared::minwindef::{WPARAM, LPARAM, LRESULT, TRUE};
use winapi::um::winuser::{
    GetSystemMetrics, SM_XVIRTUALSCREEN, SM_YVIRTUALSCREEN, SM_CXVIRTUALSCREEN,
    SM_CYVIRTUALSCREEN, CreateWindowExW, RegisterClassW, WNDCLASSW, UnregisterClassW,
    SetLayeredWindowAttributes, LWA_ALPHA, LWA_COLORKEY, LoadCursorW, IDC_HAND, IDC_ARROW, FillRect,
    FrameRect, InvalidateRect, SetCapture, ReleaseCapture, GetCursorPos, PostMessageW,
    WM_CLOSE, WM_KEYDOWN, WM_LBUTTONDOWN, WM_MOUSEMOVE, WM_LBUTTONUP, WM_PAINT,
    WM_DESTROY, VK_ESCAPE, BeginPaint, EndPaint, PAINTSTRUCT, GetMessageW,
    TranslateMessage, DispatchMessageW, MSG, DefWindowProcW, PostQuitMessage,
    WS_EX_LAYERED, WS_EX_TOPMOST, WS_EX_TOOLWINDOW, WS_POPUP, WS_VISIBLE, DrawTextW,
    GetClientRect, GetWindowTextLengthW, GetWindowTextW,
    DT_WORDBREAK, SetTimer, KillTimer, WM_TIMER, GetDC, ReleaseDC, DT_CALCRECT,
    SetCursor, WM_SETCURSOR, TrackMouseEvent, TRACKMOUSEEVENT, TME_LEAVE, WM_MOUSELEAVE,
    GetWindowRect, ShowWindow, SW_SHOW, IsWindow,
    WS_EX_NOACTIVATE, UpdateWindow, WS_EX_TRANSPARENT, FindWindowW, SetWindowTextW
};
use winapi::um::wingdi::{
    CreateCompatibleDC, CreateCompatibleBitmap, SelectObject, DeleteObject, DeleteDC,
    BitBlt, SRCCOPY, CreateSolidBrush, SetTextColor, CreateFontW, SetBkMode,
    CreateRoundRectRgn, AddFontMemResourceEx, FrameRgn, FillRgn,
    GetTextExtentPoint32W, SetTextJustification, TextOutW,
    MoveToEx, LineTo, CreatePen, PS_SOLID, TRANSPARENT, PS_INSIDEFRAME,
    PatBlt, SRCAND
};
use winapi::um::winuser::MoveWindow;
use std::sync::Mutex;
use winapi::um::libloaderapi::GetModuleHandleW;
use std::ffi::OsStr;
use std::os::windows::ffi::OsStrExt;
use std::collections::HashMap;
use std::sync::{OnceLock, Once, atomic::{AtomicU8, AtomicBool, AtomicI32, AtomicUsize, Ordering}};
use std::time::{SystemTime, UNIX_EPOCH};

use crate::config;

#[derive(Clone, Copy)]
struct Particle { x: f32, y: f32, vx: f32, vy: f32, size: i32, color: u32 }

static ANIMATION_MAP: OnceLock<Mutex<HashMap<usize, Vec<Particle>>>> = OnceLock::new();
static mut START_POS: POINT = POINT { x: 0, y: 0 };
static mut CURR_POS: POINT = POINT { x: 0, y: 0 };
static mut IS_DRAGGING: bool = false;
static OVERLAY_LIST: Mutex<Vec<usize>> = Mutex::new(Vec::new());
static HOVER_MAP: OnceLock<Mutex<HashMap<usize, bool>>> = OnceLock::new();

static SELECTION_MODE: AtomicU8 = AtomicU8::new(0);
static DEBUG_ACTIVE: AtomicBool = AtomicBool::new(false);
static CURRENT_FONT_SIZE: AtomicI32 = AtomicI32::new(24);

pub static ARROW_DEBUG_STATE: AtomicBool = AtomicBool::new(false);

// --- Biến lưu handle của cửa sổ đang Loading "..." ---
static PENDING_LOADING_HWND: AtomicUsize = AtomicUsize::new(0);

static mut FROZEN_BITMAP: HBITMAP = std::ptr::null_mut();

pub fn set_selection_mode(mode: u8) {
    SELECTION_MODE.store(mode, Ordering::Relaxed);
}

pub fn set_font_size(size: i32) {
    CURRENT_FONT_SIZE.store(size, Ordering::Relaxed);
}

pub fn is_debug_active() -> bool {
    DEBUG_ACTIVE.load(Ordering::Relaxed)
}

fn to_wide(s: &str) -> Vec<u16> { OsStr::new(s).encode_wide().chain(std::iter::once(0)).collect() }
fn simple_rng(seed: &mut u32) -> u32 { *seed = seed.wrapping_mul(1103515245).wrapping_add(12345); (*seed / 65536) % 32768 }
fn get_random_f32(seed: &mut u32, min: f32, max: f32) -> f32 { let r = simple_rng(seed) as f32 / 32768.0; min + r * (max - min) }

struct TextLine { text: Vec<u16>, width: i32, spaces: i32 }

unsafe fn break_text_into_lines(hdc: winapi::shared::windef::HDC, text: &[u16], max_width: i32) -> Vec<TextLine> {
    let mut lines = Vec::new(); let mut words = Vec::new(); let mut current_word = Vec::new();
    for &c in text { if c == 32 { if !current_word.is_empty() { words.push(current_word.clone()); current_word.clear(); } } else { current_word.push(c); } }
    if !current_word.is_empty() { words.push(current_word); }
    if words.is_empty() { return lines; }
    let mut current_line = words[0].clone(); let mut size: SIZE = std::mem::zeroed();
    GetTextExtentPoint32W(hdc, current_line.as_ptr(), current_line.len() as i32, &mut size);
    let mut current_width = size.cx;
    for i in 1..words.len() {
        let word = &words[i]; let mut test_line = current_line.clone(); test_line.push(32); test_line.extend_from_slice(word);
        GetTextExtentPoint32W(hdc, test_line.as_ptr(), test_line.len() as i32, &mut size);
        if size.cx > max_width {
            let spaces = current_line.iter().filter(|&&c| c == 32).count() as i32;
            lines.push(TextLine { text: current_line, width: current_width, spaces });
            current_line = word.clone(); GetTextExtentPoint32W(hdc, current_line.as_ptr(), current_line.len() as i32, &mut size); current_width = size.cx;
        } else { current_line = test_line; current_width = size.cx; }
    }
    if !current_line.is_empty() { let spaces = current_line.iter().filter(|&&c| c == 32).count() as i32; lines.push(TextLine { text: current_line, width: current_width, spaces }); }
    lines
}

pub fn toggle_debug_overlay() {
    let current = DEBUG_ACTIVE.load(Ordering::Relaxed);
    if current {
        DEBUG_ACTIVE.store(false, Ordering::Relaxed);
    } else {
        DEBUG_ACTIVE.store(true, Ordering::Relaxed);
        std::thread::spawn(|| {
            unsafe {
                let instance = GetModuleHandleW(std::ptr::null());
                let class_name = to_wide("DebugOverlay");
                let mut wc: WNDCLASSW = std::mem::zeroed();
                wc.lpfnWndProc = Some(debug_wnd_proc);
                wc.hInstance = instance;
                wc.lpszClassName = class_name.as_ptr();
                wc.hbrBackground = CreateSolidBrush(0x00000000);
                RegisterClassW(&wc);

                let x = GetSystemMetrics(SM_XVIRTUALSCREEN);
                let y = GetSystemMetrics(SM_YVIRTUALSCREEN);
                let w = GetSystemMetrics(SM_CXVIRTUALSCREEN);
                let h = GetSystemMetrics(SM_CYVIRTUALSCREEN);

                let hwnd = CreateWindowExW(
                    WS_EX_LAYERED | WS_EX_TOPMOST | WS_EX_TOOLWINDOW | WS_EX_TRANSPARENT,
                    class_name.as_ptr(), to_wide("DebugRects").as_ptr(), WS_POPUP | WS_VISIBLE,
                    x, y, w, h, std::ptr::null_mut(), std::ptr::null_mut(), instance, std::ptr::null_mut()
                );

                SetLayeredWindowAttributes(hwnd, 0x00000000, 0, LWA_COLORKEY);
                SetTimer(hwnd, 1, 100, None);

                let mut msg: MSG = std::mem::zeroed();
                while GetMessageW(&mut msg, std::ptr::null_mut(), 0, 0) != 0 {
                    TranslateMessage(&msg); DispatchMessageW(&msg);
                    if msg.message == WM_CLOSE { break; }
                }
                UnregisterClassW(class_name.as_ptr(), instance);
            }
        });
    }
}

unsafe extern "system" fn debug_wnd_proc(hwnd: HWND, msg: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
    match msg {
        WM_TIMER => {
            if !DEBUG_ACTIVE.load(Ordering::Relaxed) {
                KillTimer(hwnd, 1);
                PostMessageW(hwnd, WM_CLOSE, 0, 0);
            } else {
                InvalidateRect(hwnd, std::ptr::null(), 0);
            }
            0
        }
        WM_PAINT => {
            let mut ps: PAINTSTRUCT = std::mem::zeroed();
            let hdc = BeginPaint(hwnd, &mut ps);
            let mut r: RECT = std::mem::zeroed(); GetClientRect(hwnd, &mut r);

            let bg_brush = CreateSolidBrush(0x00000000);
            FillRect(hdc, &r, bg_brush);
            DeleteObject(bg_brush as *mut winapi::ctypes::c_void);

            SetBkMode(hdc, TRANSPARENT as i32);

            let debug_txt = to_wide("DEBUG MODE: ON");
            SetTextColor(hdc, 0x0000FF00);
            TextOutW(hdc, 10, 10, debug_txt.as_ptr(), debug_txt.len() as i32);

            let is_found = ARROW_DEBUG_STATE.load(Ordering::Relaxed);
            let status_text = if is_found { "MŨI TÊN: TÌM THẤY (FOUND)" } else { "MŨI TÊN: KHÔNG THẤY (MISSING)" };
            let wide_status = to_wide(status_text);
            let color = if is_found { 0x0000FF00 } else { 0x000000FF };
            SetTextColor(hdc, color);
            TextOutW(hdc, 10, 40, wide_status.as_ptr(), wide_status.len() as i32);

            let cfg = config::Config::load();
            let vx = GetSystemMetrics(SM_XVIRTUALSCREEN);
            let vy = GetSystemMetrics(SM_YVIRTUALSCREEN);

            let null_brush = winapi::um::wingdi::GetStockObject(winapi::um::wingdi::NULL_BRUSH as i32);
            let old_brush = SelectObject(hdc, null_brush);

            if !cfg.fixed_regions.is_empty() {
                let red_pen = CreatePen(PS_SOLID.try_into().unwrap(), 2, 0x000000FF);
                let old_pen = SelectObject(hdc, red_pen as *mut winapi::ctypes::c_void);
                for region in &cfg.fixed_regions {
                    let left = region.x - vx;
                    let top = region.y - vy;
                    let right = left + region.width as i32;
                    let bottom = top + region.height as i32;
                    winapi::um::wingdi::Rectangle(hdc, left, top, right, bottom);
                    let txt = to_wide("Vùng Dịch");
                    SetTextColor(hdc, 0x000000FF);
                    TextOutW(hdc, left, top - 20, txt.as_ptr(), txt.len() as i32);
                }
                SelectObject(hdc, old_pen); DeleteObject(red_pen as *mut winapi::ctypes::c_void);
            }

            if let Some(arrow) = &cfg.arrow_region {
                let yellow_pen = CreatePen(PS_SOLID.try_into().unwrap(), 2, 0x0000FFFF);
                let old_pen = SelectObject(hdc, yellow_pen as *mut winapi::ctypes::c_void);
                let left = arrow.x - vx;
                let top = arrow.y - vy;
                let right = left + arrow.width as i32;
                let bottom = top + arrow.height as i32;
                winapi::um::wingdi::Rectangle(hdc, left, top, right, bottom);
                let txt = to_wide("Mũi Tên");
                SetTextColor(hdc, 0x0000FFFF);
                TextOutW(hdc, left, top - 20, txt.as_ptr(), txt.len() as i32);
                SelectObject(hdc, old_pen); DeleteObject(yellow_pen as *mut winapi::ctypes::c_void);
            }

            if let Some(instant) = &cfg.instant_region {
                let blue_pen = CreatePen(PS_SOLID.try_into().unwrap(), 2, 0x00FF0000);
                let old_pen = SelectObject(hdc, blue_pen as *mut winapi::ctypes::c_void);
                let left = instant.x - vx;
                let top = instant.y - vy;
                let right = left + instant.width as i32;
                let bottom = top + instant.height as i32;
                winapi::um::wingdi::Rectangle(hdc, left, top, right, bottom);
                let txt = to_wide("Dịch Nhanh");
                SetTextColor(hdc, 0x00FF0000);
                TextOutW(hdc, left, top - 20, txt.as_ptr(), txt.len() as i32);
                SelectObject(hdc, old_pen); DeleteObject(blue_pen as *mut winapi::ctypes::c_void);
            }

            SelectObject(hdc, old_brush);
            EndPaint(hwnd, &mut ps); 0
        }
        WM_DESTROY => { PostQuitMessage(0); 0 }
        _ => DefWindowProcW(hwnd, msg, wparam, lparam),
    }
}

pub fn show_selection_overlay() {
    unsafe {
        IS_DRAGGING = false;
        let config = config::Config::load();

        FROZEN_BITMAP = std::ptr::null_mut();
        if config.freeze_screen {
            let x = GetSystemMetrics(SM_XVIRTUALSCREEN);
            let y = GetSystemMetrics(SM_YVIRTUALSCREEN);
            let w = GetSystemMetrics(SM_CXVIRTUALSCREEN);
            let h = GetSystemMetrics(SM_CYVIRTUALSCREEN);

            let hdc_screen = GetDC(std::ptr::null_mut());
            let hdc_mem = CreateCompatibleDC(hdc_screen);
            let hbm = CreateCompatibleBitmap(hdc_screen, w, h);
            SelectObject(hdc_mem, hbm as *mut _);
            BitBlt(hdc_mem, 0, 0, w, h, hdc_screen, x, y, SRCCOPY);

            FROZEN_BITMAP = hbm;

            DeleteDC(hdc_mem);
            ReleaseDC(std::ptr::null_mut(), hdc_screen);
        }

        let instance = GetModuleHandleW(std::ptr::null());
        let class_name = to_wide("SnippingOverlay");
        let mut wc: WNDCLASSW = std::mem::zeroed();
        wc.lpfnWndProc = Some(selection_wnd_proc);
        wc.hInstance = instance;
        wc.lpszClassName = class_name.as_ptr();
        wc.hbrBackground = CreateSolidBrush(0x00FF00FF);
        RegisterClassW(&wc);

        let x = GetSystemMetrics(SM_XVIRTUALSCREEN);
        let y = GetSystemMetrics(SM_YVIRTUALSCREEN);
        let w = GetSystemMetrics(SM_CXVIRTUALSCREEN);
        let h = GetSystemMetrics(SM_CYVIRTUALSCREEN);

        let ex_style = WS_EX_LAYERED | WS_EX_TOPMOST | WS_EX_TOOLWINDOW;
        let hwnd = CreateWindowExW(ex_style, class_name.as_ptr(), to_wide("Snipping").as_ptr(), WS_POPUP, x, y, w, h, std::ptr::null_mut(), std::ptr::null_mut(), instance, std::ptr::null_mut());

        if config.freeze_screen {
             SetLayeredWindowAttributes(hwnd, 0, 255, LWA_ALPHA);
        } else {
             SetLayeredWindowAttributes(hwnd, 0x00FF00FF, 100, LWA_ALPHA | LWA_COLORKEY);
        }

        GetCursorPos(std::ptr::addr_of_mut!(CURR_POS));
        ShowWindow(hwnd, SW_SHOW);

        let mut msg: MSG = std::mem::zeroed();
        while GetMessageW(&mut msg, std::ptr::null_mut(), 0, 0) != 0 {
            TranslateMessage(&msg); DispatchMessageW(&msg);
            if msg.message == WM_CLOSE { break; }
        }

        if !FROZEN_BITMAP.is_null() {
            DeleteObject(FROZEN_BITMAP as *mut _);
            FROZEN_BITMAP = std::ptr::null_mut();
        }

        UnregisterClassW(class_name.as_ptr(), instance);
    }
}

unsafe extern "system" fn selection_wnd_proc(hwnd: HWND, msg: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
    match msg {
        WM_KEYDOWN => { if wparam == VK_ESCAPE as usize { PostMessageW(hwnd, WM_CLOSE, 0, 0); } 0 }
        WM_LBUTTONDOWN => {
            IS_DRAGGING = true; GetCursorPos(std::ptr::addr_of_mut!(START_POS)); CURR_POS = START_POS;
            SetCapture(hwnd); InvalidateRect(hwnd, std::ptr::null(), 0);
            UpdateWindow(hwnd);
            0
        }
        WM_MOUSEMOVE => {
            GetCursorPos(std::ptr::addr_of_mut!(CURR_POS));
            InvalidateRect(hwnd, std::ptr::null(), 0);
            UpdateWindow(hwnd);
            0
        }
        WM_LBUTTONUP => {
            if IS_DRAGGING {
                IS_DRAGGING = false; ReleaseCapture();
                let rect = RECT { left: START_POS.x.min(CURR_POS.x), top: START_POS.y.min(CURR_POS.y), right: START_POS.x.max(CURR_POS.x), bottom: START_POS.y.max(CURR_POS.y) };
                if (rect.right - rect.left) > 10 && (rect.bottom - rect.top) > 10 {
                    let region = config::Region { x: rect.left, y: rect.top, width: (rect.right - rect.left) as u32, height: (rect.bottom - rect.top) as u32 };
                    let hwnd_usize = hwnd as usize;
                    std::thread::spawn(move || { process_region(region); unsafe { PostMessageW(hwnd_usize as HWND, WM_CLOSE, 0, 0); } });
                } else { PostMessageW(hwnd, WM_CLOSE, 0, 0); }
            } 0
        }
        WM_SETCURSOR => {
            let mode = SELECTION_MODE.load(Ordering::Relaxed);
            if mode == 2 {
                SetCursor(LoadCursorW(std::ptr::null_mut(), IDC_ARROW));
            } else {
                SetCursor(std::ptr::null_mut());
            }
            1
        }
        WM_PAINT => {
            let mut ps: PAINTSTRUCT = std::mem::zeroed();
            let hdc = BeginPaint(hwnd, &mut ps);
            let mem_dc = CreateCompatibleDC(hdc);
            let w = GetSystemMetrics(SM_CXVIRTUALSCREEN); let h = GetSystemMetrics(SM_CYVIRTUALSCREEN);
            let vx = GetSystemMetrics(SM_XVIRTUALSCREEN); let vy = GetSystemMetrics(SM_YVIRTUALSCREEN);

            let mem_bm = CreateCompatibleBitmap(hdc, w, h); SelectObject(mem_dc, mem_bm as *mut winapi::ctypes::c_void);
            let mode = SELECTION_MODE.load(Ordering::Relaxed);

            if !FROZEN_BITMAP.is_null() {
                // === FREEZE MODE ===
                let hdc_src = CreateCompatibleDC(hdc);
                SelectObject(hdc_src, FROZEN_BITMAP as *mut _);

                // 1. Draw source
                BitBlt(mem_dc, 0, 0, w, h, hdc_src, 0, 0, SRCCOPY);

                // 2. Dim screen
                let dim_brush = CreateSolidBrush(0x00404040);
                let old_brush = SelectObject(mem_dc, dim_brush as *mut _);
                PatBlt(mem_dc, 0, 0, w, h, SRCAND);
                SelectObject(mem_dc, old_brush);
                DeleteObject(dim_brush as *mut _);

                // 3. Border
                let pen_screen_border = CreatePen(PS_INSIDEFRAME as i32, 6, 0x00FF0000); // Blue (BGR)
                let old_pen_border = SelectObject(mem_dc, pen_screen_border as *mut _);
                let null_brush = winapi::um::wingdi::GetStockObject(winapi::um::wingdi::NULL_BRUSH as i32);
                let old_br_border = SelectObject(mem_dc, null_brush);
                winapi::um::wingdi::Rectangle(mem_dc, 0, 0, w, h);
                SelectObject(mem_dc, old_br_border);
                SelectObject(mem_dc, old_pen_border);
                DeleteObject(pen_screen_border as *mut _);

                // 4. Dragging rect
                if IS_DRAGGING {
                     let r = RECT {
                        left: (START_POS.x.min(CURR_POS.x)) - vx,
                        top: (START_POS.y.min(CURR_POS.y)) - vy,
                        right: (START_POS.x.max(CURR_POS.x)) - vx,
                        bottom: (START_POS.y.max(CURR_POS.y)) - vy
                    };

                    // Copy bright part from src
                    BitBlt(mem_dc, r.left, r.top, r.right - r.left, r.bottom - r.top,
                           hdc_src, r.left, r.top, SRCCOPY);

                    let color = if mode == 1 { 0x00FFFF00 } else if mode == 2 { 0x000080FF } else { 0x00FF00FF };
                    let pen_border = CreatePen(PS_SOLID.try_into().unwrap(), 2, color);
                    let old_pen = SelectObject(mem_dc, pen_border as *mut _);
                    let old_br = SelectObject(mem_dc, null_brush);

                    winapi::um::wingdi::Rectangle(mem_dc, r.left, r.top, r.right, r.bottom);

                    SelectObject(mem_dc, old_br);
                    SelectObject(mem_dc, old_pen);
                    DeleteObject(pen_border as *mut _);
                }

                DeleteDC(hdc_src);

            } else {
                // === NORMAL MODE ===
                let bg_brush = CreateSolidBrush(0x00000000);
                FillRect(mem_dc, &RECT{left:0,top:0,right:w,bottom:h}, bg_brush);
                DeleteObject(bg_brush as *mut winapi::ctypes::c_void);

                if IS_DRAGGING {
                    let r = RECT {
                        left: (START_POS.x.min(CURR_POS.x)) - vx,
                        top: (START_POS.y.min(CURR_POS.y)) - vy,
                        right: (START_POS.x.max(CURR_POS.x)) - vx,
                        bottom: (START_POS.y.max(CURR_POS.y)) - vy
                    };

                    let color = if mode == 1 { 0x00FFFF00 } else if mode == 2 { 0x000080FF } else { 0x00FF00FF };
                    let k_br = CreateSolidBrush(color);
                    FillRect(mem_dc, &r, k_br);
                    DeleteObject(k_br as *mut winapi::ctypes::c_void);

                    let b_br = CreateSolidBrush(0x00FFFFFF); FrameRect(mem_dc, &r, b_br); DeleteObject(b_br as *mut winapi::ctypes::c_void);
                }
            }

            if mode != 2 {
                let cx = CURR_POS.x - vx;
                let cy = CURR_POS.y - vy;
                let pen = CreatePen(PS_SOLID.try_into().unwrap(), 2, 0x000000FF);
                let old_pen = SelectObject(mem_dc, pen as *mut winapi::ctypes::c_void);
                MoveToEx(mem_dc, 0, cy, std::ptr::null_mut()); LineTo(mem_dc, w, cy);
                MoveToEx(mem_dc, cx, 0, std::ptr::null_mut()); LineTo(mem_dc, cx, h);
                SelectObject(mem_dc, old_pen); DeleteObject(pen as *mut winapi::ctypes::c_void);
            }

            BitBlt(hdc, 0, 0, w, h, mem_dc, 0, 0, SRCCOPY);
            DeleteObject(mem_bm as *mut winapi::ctypes::c_void); DeleteDC(mem_dc); EndPaint(hwnd, &mut ps); 0
        }
        WM_DESTROY => { PostQuitMessage(0); 0 }
        _ => DefWindowProcW(hwnd, msg, wparam, lparam),
    }
}

fn process_region(region: config::Region) {
    let mut config = config::Config::load();
    let mode = SELECTION_MODE.load(Ordering::Relaxed);

    if mode == 0 {
        config.fixed_regions.clear();
        config.fixed_regions.push(region);
    } else if mode == 1 {
        config.arrow_region = Some(region);
    } else if mode == 2 {
        config.instant_region = Some(region);
    } else if mode >= 100 {
        let idx = (mode - 100) as usize;
        if idx < config.aux_regions.len() {
            config.aux_regions[idx].region = Some(region);
        }
    }
    config.save().unwrap();
}

pub fn show_highlight(rect: RECT) {
    std::thread::spawn(move || {
        unsafe {
            let instance = GetModuleHandleW(std::ptr::null());
            let class_name = to_wide("HighlightOverlay");
            let mut wc: WNDCLASSW = std::mem::zeroed();
            wc.lpfnWndProc = Some(highlight_wnd_proc);
            wc.hInstance = instance;
            wc.lpszClassName = class_name.as_ptr();
            wc.hbrBackground = CreateSolidBrush(0x0000FF00);
            RegisterClassW(&wc);

            let hwnd = CreateWindowExW(
                WS_EX_LAYERED | WS_EX_TOPMOST | WS_EX_TOOLWINDOW,
                class_name.as_ptr(), to_wide("Highlight").as_ptr(), WS_POPUP | WS_VISIBLE,
                rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
                std::ptr::null_mut(), std::ptr::null_mut(), instance, std::ptr::null_mut()
            );

            SetLayeredWindowAttributes(hwnd, 0, 100, 0x00000002);
            SetTimer(hwnd, 999, 3000, None);

            let mut msg: MSG = std::mem::zeroed();
            while GetMessageW(&mut msg, std::ptr::null_mut(), 0, 0) != 0 {
                TranslateMessage(&msg); DispatchMessageW(&msg);
                if msg.message == WM_CLOSE { break; }
            }
            UnregisterClassW(class_name.as_ptr(), instance);
        }
    });
}

static REGISTER_RESULT_CLASS: Once = Once::new();
pub fn show_loading_window(rect: RECT) {
    show_result_window_internal(rect, "...".to_string(), 20000, true);
}

// --- HÀM MỚI: Cập nhật nội dung cửa sổ "Loading" ---
pub fn update_loading_window(text: String) -> bool { // Thêm -> bool
    let hwnd_val = PENDING_LOADING_HWND.load(Ordering::Relaxed);
    if hwnd_val == 0 { return false; } // Trả về false
    let hwnd = hwnd_val as HWND;
    if unsafe { IsWindow(hwnd) } == 0 { return false; } // Trả về false

    unsafe {
        // Reset thời gian tắt (vì đã có kết quả)
        SetTimer(hwnd, 1, 20000, None); // Ví dụ: 20s để đọc

        // Tính lại chiều cao mới
        let hdc = GetDC(hwnd);
        let font_size = CURRENT_FONT_SIZE.load(Ordering::Relaxed);
        let hfont = CreateFontW(font_size, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 2, 0, to_wide("Roboto").as_ptr());
        SelectObject(hdc, hfont as *mut winapi::ctypes::c_void);

        let mut rect: RECT = std::mem::zeroed();
        GetWindowRect(hwnd, &mut rect);
        let width = rect.right - rect.left;
        let padding = 10;
        let max_text_width = width - padding * 2;

        let mut text_rect = RECT { left: 0, top: 0, right: max_text_width, bottom: 0 };
        let wide_text = to_wide(&text);
        DrawTextW(hdc, wide_text.as_ptr(), -1, &mut text_rect, DT_CALCRECT | DT_WORDBREAK);
        let new_height = (text_rect.bottom - text_rect.top) + padding * 2;

        DeleteObject(hfont as *mut winapi::ctypes::c_void);
        ReleaseDC(hwnd, hdc);

        // Cập nhật text & Resize
        SetWindowTextW(hwnd, wide_text.as_ptr());
        MoveWindow(hwnd, rect.left, rect.top, width, new_height, 1);
        InvalidateRect(hwnd, std::ptr::null(), TRUE);

        // Reset cờ chờ
        PENDING_LOADING_HWND.store(0, Ordering::Relaxed);
    }
    true // Trả về true
}

// --- HÀM CHUNG ---
fn show_result_window_internal(target_rect: RECT, text: String, duration_ms: u32, is_loading: bool) {
    unsafe {
        let instance = GetModuleHandleW(std::ptr::null());
        let class_name = to_wide("TranslationResult");
        REGISTER_RESULT_CLASS.call_once(|| {
            let mut wc: WNDCLASSW = std::mem::zeroed();
            wc.lpfnWndProc = Some(result_wnd_proc);
            wc.hInstance = instance;
            wc.lpszClassName = class_name.as_ptr();
            wc.hbrBackground = CreateSolidBrush(0x00FF00FF);
            wc.style = winapi::um::winuser::CS_HREDRAW | winapi::um::winuser::CS_VREDRAW;
            RegisterClassW(&wc);
        });

        let region_width = (target_rect.right - target_rect.left).abs();
        let hdc_screen = GetDC(std::ptr::null_mut());

        let font_size = CURRENT_FONT_SIZE.load(Ordering::Relaxed);
        let hfont = CreateFontW(font_size, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 2, 0, to_wide("Roboto").as_ptr());

        SelectObject(hdc_screen, hfont as *mut winapi::ctypes::c_void);
        let padding = 10; let max_text_width = region_width - padding * 2;
        let mut text_rect = RECT { left: 0, top: 0, right: max_text_width, bottom: 0 };
        let wide_text = to_wide(&text);
        DrawTextW(hdc_screen, wide_text.as_ptr(), -1, &mut text_rect, DT_CALCRECT | DT_WORDBREAK);
        let text_height = text_rect.bottom - text_rect.top;
        DeleteObject(hfont as *mut winapi::ctypes::c_void);
        ReleaseDC(std::ptr::null_mut(), hdc_screen);

        let height = text_height + padding * 2;
        let x = target_rect.left;
        let width = region_width as i32;
        let mut y = target_rect.top - height - 10;
        if y < 0 { y = target_rect.top + 10; } // Fallback nếu sát mép trên

        // --- PUSH UP LOGIC (ĐẨY CÁC CỬA SỔ CŨ LÊN) ---
        let valid_hwnds: Vec<HWND> = {
            let mut list = OVERLAY_LIST.lock().unwrap();
            list.retain(|&h| IsWindow(h as HWND) != 0);
            list.iter().map(|&h| h as HWND).collect()
        };
        for hwnd in valid_hwnds {
            let mut r = RECT { left: 0, top: 0, right: 0, bottom: 0 };
            if GetWindowRect(hwnd, &mut r) != 0 {
                // Đẩy lên đúng bằng chiều cao cửa sổ mới + khoảng cách
                MoveWindow(hwnd, r.left, r.top - height - 10, r.right - r.left, r.bottom - r.top, 1);
            }
        }
        // ---------------------------------------------

        let font_data = include_bytes!("roboto.ttf");
        let _ = AddFontMemResourceEx(font_data.as_ptr() as *mut winapi::ctypes::c_void, font_data.len() as u32, std::ptr::null_mut(), &mut 0);

        let hwnd = CreateWindowExW(
            WS_EX_TOPMOST | WS_EX_LAYERED | WS_EX_TOOLWINDOW | WS_EX_NOACTIVATE,
            class_name.as_ptr(), to_wide(&text).as_ptr(), WS_POPUP | WS_VISIBLE, x, y, width, height, std::ptr::null_mut(), std::ptr::null_mut(), instance, std::ptr::null_mut());

        if !hwnd.is_null() {
            {
                let mut list = OVERLAY_LIST.lock().unwrap();
                list.push(hwnd as usize);
            }

            // Nếu là cửa sổ Loading, lưu lại Handle để cập nhật sau
            if is_loading {
                PENDING_LOADING_HWND.store(hwnd as usize, Ordering::Relaxed);
            }

            SetLayeredWindowAttributes(hwnd, 0x00FF00FF, 200, LWA_ALPHA | LWA_COLORKEY);
            SetTimer(hwnd, 1, duration_ms, None);

            let mut msg: MSG = std::mem::zeroed();
            while GetMessageW(&mut msg, std::ptr::null_mut(), 0, 0) != 0 {
                TranslateMessage(&msg); DispatchMessageW(&msg);
                if msg.message == WM_CLOSE { break; }
            }
        }
    }
}

pub fn show_result_window(target_rect: RECT, text: String, duration_ms: u32) {
    show_result_window_internal(target_rect, text, duration_ms, false);
}

unsafe extern "system" fn highlight_wnd_proc(hwnd: HWND, msg: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
    match msg {
        WM_PAINT => {
            let mut ps: PAINTSTRUCT = std::mem::zeroed();
            let hdc = BeginPaint(hwnd, &mut ps);
            let mut r: RECT = std::mem::zeroed(); GetClientRect(hwnd, &mut r);

            let fill_brush = CreateSolidBrush(0x0000FF00);
            FillRect(hdc, &r, fill_brush);
            DeleteObject(fill_brush as *mut winapi::ctypes::c_void);

            let border_brush = CreateSolidBrush(0x000000FF);
            FrameRect(hdc, &r, border_brush);
            let mut r2 = r; r2.left += 1; r2.top += 1; r2.right -= 1; r2.bottom -= 1;
            FrameRect(hdc, &r2, border_brush);
            let mut r3 = r2; r3.left += 1; r3.top += 1; r3.right -= 1; r3.bottom -= 1;
            FrameRect(hdc, &r3, border_brush);

            DeleteObject(border_brush as *mut winapi::ctypes::c_void);
            EndPaint(hwnd, &mut ps); 0
        }
        WM_TIMER => { if wparam == 999 { KillTimer(hwnd, 999); PostMessageW(hwnd, WM_CLOSE, 0, 0); } 0 }
        WM_DESTROY => { PostQuitMessage(0); 0 }
        _ => DefWindowProcW(hwnd, msg, wparam, lparam),
    }
}


unsafe extern "system" fn result_wnd_proc(hwnd: HWND, msg: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
    match msg {
        WM_PAINT => {
            let mut ps: PAINTSTRUCT = std::mem::zeroed();
            let hdc = BeginPaint(hwnd, &mut ps);
            let mut rect: RECT = std::mem::zeroed(); GetClientRect(hwnd, &mut rect);
            let mem_dc = CreateCompatibleDC(hdc); let mem_bm = CreateCompatibleBitmap(hdc, rect.right, rect.bottom); SelectObject(mem_dc, mem_bm as *mut winapi::ctypes::c_void);
            let k_br = CreateSolidBrush(0x00FF00FF); FillRect(mem_dc, &rect, k_br); DeleteObject(k_br as *mut winapi::ctypes::c_void);

            // Vẽ nền đen mờ
            let hrgn = CreateRoundRectRgn(0, 0, rect.right, rect.bottom, 8, 8); let bg_br = CreateSolidBrush(0x00000000); FillRgn(mem_dc, hrgn, bg_br); DeleteObject(bg_br as *mut winapi::ctypes::c_void);
            { let map_mutex = HOVER_MAP.get_or_init(|| Mutex::new(HashMap::new())); let map = map_mutex.lock().unwrap(); if *map.get(&(hwnd as usize)).unwrap_or(&false) { let g_br = CreateSolidBrush(0x0000FF00); FrameRgn(mem_dc, hrgn, g_br, 2, 2); DeleteObject(g_br as *mut winapi::ctypes::c_void); } }
            SetBkMode(mem_dc, 1); SetTextColor(mem_dc, 0x00FFFFFF);
            let font_size = CURRENT_FONT_SIZE.load(Ordering::Relaxed);
            let hfont = CreateFontW(font_size, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 2, 0, to_wide("Roboto").as_ptr());
            let old_font = SelectObject(mem_dc, hfont as *mut winapi::ctypes::c_void);
            let len = GetWindowTextLengthW(hwnd) + 1; let mut buf = vec![0u16; len as usize]; GetWindowTextW(hwnd, buf.as_mut_ptr(), len); let v_len = buf.iter().position(|&c| c == 0).unwrap_or(buf.len());
            let lines = break_text_into_lines(mem_dc, &buf[0..v_len], (rect.right - rect.left) - 20); let mut sz: SIZE = std::mem::zeroed(); GetTextExtentPoint32W(mem_dc, to_wide("A").as_ptr(), 1, &mut sz); let start_y = (rect.bottom - rect.top - (sz.cy * lines.len() as i32)) / 2;
            for (i, line) in lines.iter().enumerate() { let y = start_y + (i as i32 * sz.cy); if i < lines.len() - 1 && line.spaces > 0 { SetTextJustification(mem_dc, ((rect.right - rect.left) - 20) - line.width, line.spaces as i32); TextOutW(mem_dc, 10, y, line.text.as_ptr(), line.text.len() as i32); SetTextJustification(mem_dc, 0, 0); } else { TextOutW(mem_dc, (rect.right - rect.left - line.width) / 2, y, line.text.as_ptr(), line.text.len() as i32); } }
            SelectObject(mem_dc, old_font); DeleteObject(hfont as *mut winapi::ctypes::c_void); DeleteObject(hrgn as *mut winapi::ctypes::c_void);

            BitBlt(hdc, 0, 0, rect.right, rect.bottom, mem_dc, 0, 0, SRCCOPY); DeleteObject(mem_bm as *mut winapi::ctypes::c_void); DeleteDC(mem_dc); EndPaint(hwnd, &mut ps); 0
        }
        WM_LBUTTONUP => {
            // Dừng đọc
            crate::tts::stop();
            // Gửi lệnh đóng cửa sổ ngay lập tức
            PostMessageW(hwnd, WM_CLOSE, 0, 0);
            0
        }
        WM_TIMER => { if wparam == 1 { KillTimer(hwnd, 1); PostMessageW(hwnd, WM_CLOSE, 0, 0); } else if wparam == 3 { let mut close = false; { let map_mutex = ANIMATION_MAP.get_or_init(|| Mutex::new(HashMap::new())); let mut map = map_mutex.lock().unwrap(); if let Some(p) = map.get_mut(&(hwnd as usize)) { let mut cnt = 0; let mut r = RECT{left:0,top:0,right:0,bottom:0}; GetClientRect(hwnd, &mut r); for i in p.iter_mut() { i.x+=i.vx; i.y+=i.vy; i.vy+=0.5; if i.y < (r.bottom+100) as f32 { cnt+=1; } } if cnt == 0 { close = true; } } else { close = true; } } if close { KillTimer(hwnd, 3); PostMessageW(hwnd, WM_CLOSE, 0, 0); } else { InvalidateRect(hwnd, std::ptr::null(), 0); } } 0 }
        WM_DESTROY => { { let mut map = HOVER_MAP.get_or_init(|| Mutex::new(HashMap::new())).lock().unwrap(); map.remove(&(hwnd as usize)); } { let mut map = ANIMATION_MAP.get_or_init(|| Mutex::new(HashMap::new())).lock().unwrap(); map.remove(&(hwnd as usize)); } { let mut list = OVERLAY_LIST.lock().unwrap(); list.retain(|&h| h != hwnd as usize); } PostQuitMessage(0); 0 }
        WM_KEYDOWN => { if wparam == VK_ESCAPE as usize { PostMessageW(hwnd, WM_CLOSE, 0, 0); } 0 }
        WM_SETCURSOR => { SetCursor(LoadCursorW(std::ptr::null_mut(), IDC_HAND)); 1 }
        WM_MOUSEMOVE => { let anim = { ANIMATION_MAP.get_or_init(|| Mutex::new(HashMap::new())).lock().unwrap().contains_key(&(hwnd as usize)) }; if !anim { let map_mutex = HOVER_MAP.get_or_init(|| Mutex::new(HashMap::new())); let mut map = map_mutex.lock().unwrap(); if !*map.get(&(hwnd as usize)).unwrap_or(&false) { map.insert(hwnd as usize, true); let mut t = TRACKMOUSEEVENT{cbSize:std::mem::size_of::<TRACKMOUSEEVENT>() as u32, dwFlags:TME_LEAVE, hwndTrack:hwnd, dwHoverTime:0}; unsafe { TrackMouseEvent(&mut t); InvalidateRect(hwnd, std::ptr::null(), 0); } } } 0 }
        WM_MOUSELEAVE => { let anim = { ANIMATION_MAP.get_or_init(|| Mutex::new(HashMap::new())).lock().unwrap().contains_key(&(hwnd as usize)) }; if !anim { HOVER_MAP.get_or_init(|| Mutex::new(HashMap::new())).lock().unwrap().insert(hwnd as usize, false); unsafe { InvalidateRect(hwnd, std::ptr::null(), 0); } } 0 }
        _ => DefWindowProcW(hwnd, msg, wparam, lparam),
    }
}
</file>

<file path="src/config.rs">
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::PathBuf;

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct Region {
    pub x: i32,
    pub y: i32,
    pub width: u32,
    pub height: u32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CustomPrompt {
    pub content: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct AuxRegion {
    pub id: usize,
    pub name: String,
    pub region: Option<Region>,
    pub hotkey_select: String,
    pub hotkey_translate: String,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct Config {
    pub gemini_api_key: String,
    #[serde(default)]
    pub groq_api_keys: Vec<String>,
    #[serde(default)]
    pub active_groq_index: usize,

    pub current_prompt: String,

    #[serde(default)]
    pub saved_prompts: Vec<CustomPrompt>,

    pub hotkey_translate: String,
    pub hotkey_select: String,
    pub hotkey_instant: String,
    pub hotkey_auto: String,
    pub hotkey_toggle_auto: String,
    pub split_tts: bool,
    pub use_tts: bool,
    pub show_overlay: bool,

    pub fixed_regions: Vec<Region>,
    pub arrow_region: Option<Region>,
    pub instant_region: Option<Region>,

    #[serde(default)]
    pub aux_regions: Vec<AuxRegion>,

    pub selected_api: String,
    pub speed: f32,

    #[serde(default = "default_interval")]
    pub arrow_check_interval: f32,
    #[serde(default)]
    pub auto_copy: bool,
    #[serde(default)]
    pub copy_instant_only: bool,

    #[serde(default)]
    pub copy_original: bool,

    #[serde(default = "default_font_size")]
    pub overlay_font_size: i32,

    #[serde(default = "default_dark_mode")]
    pub is_dark_mode: bool,

    #[serde(default)]
    pub freeze_screen: bool,
}

// --- SỬA Ở ĐÂY: Mặc định là 0.1 giây ---
fn default_interval() -> f32 { 0.1 }
// ---------------------------------------
fn default_font_size() -> i32 { 24 }
fn default_dark_mode() -> bool { false }

impl Default for Config {
    fn default() -> Self {
        Self {
            gemini_api_key: String::new(),
            groq_api_keys: Vec::new(),
            active_groq_index: 0,
            current_prompt: Self::get_normal_prompt(),
            saved_prompts: Vec::new(),
            hotkey_translate: "[".to_string(),
            hotkey_select: "]".to_string(),
            hotkey_instant: "\\".to_string(),
            hotkey_auto: ";".to_string(),
            hotkey_toggle_auto: "=".to_string(),
            split_tts: true,
            use_tts: true,
            show_overlay: true,
            speed: 1.45,
            fixed_regions: Vec::new(),
            arrow_region: None,
            instant_region: None,
            aux_regions: Vec::new(),
            selected_api: "groq".to_string(),
            // Đảm bảo load mặc định cũng là 0.1
            arrow_check_interval: 0.1,
            auto_copy: false,
            copy_instant_only: false,
            copy_original: false,
            overlay_font_size: 24,
            is_dark_mode: false,
            freeze_screen: false,
        }
    }
}

impl Config {
    pub fn get_wuxia_prompt() -> String {
        "Perform OCR to extract all text from this image, regardless of the source language. Then, translate the extracted text into Vietnamese. The translation must strictly use vocabulary and tone consistent with wuxia novels, make it as short as possible. Crucially, provide ONLY the translated text and nothing else. Do not include any introductory phrases, explanations, or conversational elements. Note: just output the translated text and make it as short as possible".to_string()
    }

    pub fn get_wuxia_speaker_prompt() -> String {
        "Perform OCR to extract text. Check if a character name appears at the start. 
        1. If Name exists: Output format 'Name Verb: Translated Text'. (Choose verb based on context: nói, cười lạnh, quát, than...).
        2. If NO Name exists: Output ONLY the 'Translated Text'.
        CRITICAL RULES:
        - Do NOT output phrases like 'No character name found', 'No name detected', or any explanations.
        - If you are unsure, just output the translation.
        - Translate to Vietnamese wuxia style (Kiếm hiệp).
        - Do NOT use quotation marks.".to_string()
    }

    pub fn get_normal_prompt() -> String {
        "Perform OCR to extract all text visible in this image, regardless of the original language. Then, translate the extracted text directly into Vietnamese. Return only the Vietnamese translation, no introduction or notes.".to_string()
    }

    pub fn get_analyze_prompt() -> String {
        "Analyze the content of this image and provide a brief description in Vietnamese. Strictly output the analysis only, keep it short and concise. Do not add any introductory text or extra notes.".to_string()
    }

    pub fn get_extract_text_prompt() -> String {
        "Perform OCR to extract all text from this image exactly as it appears. Output ONLY the extracted text, regardless of the language. Do not add any notes or explanations.".to_string()
    }

    pub fn get_config_dir() -> PathBuf {
        let home = std::env::var("USERPROFILE").unwrap_or_else(|_| ".".to_string());
        std::path::Path::new(&home).join(".screen_translator")
    }

    fn get_config_path() -> PathBuf {
        Self::get_config_dir().join("config.txt")
    }

    pub fn get_custom_arrow_path() -> PathBuf {
        Self::get_config_dir().join("custom_arrow.png")
    }

    pub fn load() -> Self {
        let path = Self::get_config_path();
        if path.exists() {
            match fs::read_to_string(path) {
                Ok(content) => {
                    let mut config: Config = serde_json::from_str(&content).unwrap_or_default();
                    if config.active_groq_index >= config.groq_api_keys.len() && !config.groq_api_keys.is_empty() {
                        config.active_groq_index = 0;
                    }
                    if config.arrow_check_interval < 0.02 { config.arrow_check_interval = 0.02; }
                    if config.arrow_check_interval > 0.2 { config.arrow_check_interval = 0.2; }
                    if config.overlay_font_size < 10 { config.overlay_font_size = 10; }
                    if config.overlay_font_size > 72 { config.overlay_font_size = 72; }
                    config.split_tts = true;
                    config
                },
                Err(_) => Self::default(),
            }
        } else {
            Self::default()
        }
    }

    pub fn save(&self) -> Result<(), Box<dyn std::error::Error>> {
        let content = serde_json::to_string_pretty(self)?;
        let path = Self::get_config_path();
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)?;
        }
        fs::write(path, content)?;
        Ok(())
    }

    pub fn get_current_groq_key(&self) -> String {
        if self.groq_api_keys.is_empty() { return String::new(); }
        if self.active_groq_index < self.groq_api_keys.len() { self.groq_api_keys[self.active_groq_index].clone() }
        else { self.groq_api_keys[0].clone() }
    }
}
</file>

<file path="src/capture.rs">
use image::{DynamicImage, ImageFormat, imageops::FilterType, RgbaImage};
use screenshots::Screen;
use std::sync::Mutex;
use std::sync::atomic::{AtomicU8, Ordering};

// Biến toàn cục để lưu lại "kích thước mũi tên đúng nhất"
static CACHED_TEMPLATE: Mutex<Option<RgbaImage>> = Mutex::new(None);

// Bộ đếm để hạn chế tần suất quét kỹ
static SCAN_COUNTER: AtomicU8 = AtomicU8::new(0);

/// Tìm màn hình chứa điểm (x, y)
fn find_screen_containing(x: i32, y: i32, screens: &[Screen]) -> Option<&Screen> {
    screens.iter().find(|s| {
        let info = s.display_info;
        x >= info.x
        && x < info.x + info.width as i32
        && y >= info.y
        && y < info.y + info.height as i32
    })
}

pub fn capture_image(region: &crate::config::Region) -> Result<Vec<u8>, anyhow::Error> {
    let screens = Screen::all()?;
    if screens.is_empty() { return Err(anyhow::anyhow!("No screens found")); }

    let screen = find_screen_containing(region.x, region.y, &screens)
        .unwrap_or(&screens[0]);

    let relative_x = region.x - screen.display_info.x;
    let relative_y = region.y - screen.display_info.y;

    let image = screen.capture_area(relative_x, relative_y, region.width, region.height)?;
    let img = DynamicImage::ImageRgba8(image);
    let mut buffer = Vec::new();
    img.write_to(&mut std::io::Cursor::new(&mut buffer), ImageFormat::Png)?;
    Ok(buffer)
}

pub fn is_template_present(region: &crate::config::Region, template_bytes: &[u8]) -> bool {
    let screens = match Screen::all() {
        Ok(s) => s,
        Err(_) => return false,
    };
    if screens.is_empty() { return false; }

    let screen = find_screen_containing(region.x, region.y, &screens)
        .unwrap_or(&screens[0]);

    let relative_x = region.x - screen.display_info.x;
    let relative_y = region.y - screen.display_info.y;

    let captured_image = match screen.capture_area(relative_x, relative_y, region.width, region.height) {
        Ok(img) => DynamicImage::ImageRgba8(img),
        Err(_) => return false,
    };

    let haystack = captured_image.to_rgba8();

    let template_original = match image::load_from_memory(template_bytes) {
        Ok(img) => img.to_rgba8(),
        Err(_) => return false,
    };

    // --- CHIẾN LƯỢC QUÉT ---

    // 1. Kiểm tra Cache trước
    {
        let cached = CACHED_TEMPLATE.lock().unwrap();
        if let Some(ref cached_img) = *cached {
            if check_match_at_scale(&haystack, cached_img) {
                SCAN_COUNTER.store(0, Ordering::Relaxed);
                return true;
            }
        }
    }

    // 2. Kiểm tra ảnh gốc
    if check_match_at_scale(&haystack, &template_original) {
        let mut cached = CACHED_TEMPLATE.lock().unwrap();
        *cached = Some(template_original);
        SCAN_COUNTER.store(0, Ordering::Relaxed);
        return true;
    }

    // 3. Quét đa tỉ lệ (Chạy mỗi 5 frame)
    let counter = SCAN_COUNTER.fetch_add(1, Ordering::Relaxed);
    if counter % 5 != 0 {
        return false;
    }

    // Mở rộng dải scale một chút để dễ bắt hơn, nhưng vẫn tránh mức 0.5 (quá nhỏ)
    let scales = [
        1.0,
        0.95, 1.05,
        0.9, 1.1,
        0.8, 1.2,
        0.75, 1.25,
        0.7, 1.3
    ];

    for scale in scales {
        let (orig_w, orig_h) = template_original.dimensions();
        let new_w = (orig_w as f32 * scale) as u32;
        let new_h = (orig_h as f32 * scale) as u32;

        if new_w < 5 || new_h < 5 { continue; }

        let template_resized = image::imageops::resize(
            &template_original,
            new_w,
            new_h,
            FilterType::Lanczos3
        );

        if check_match_at_scale(&haystack, &template_resized) {
            let mut cached = CACHED_TEMPLATE.lock().unwrap();
            *cached = Some(template_resized);
            SCAN_COUNTER.store(0, Ordering::Relaxed);
            return true;
        }
    }

    false
}

fn check_match_at_scale(haystack: &RgbaImage, needle: &RgbaImage) -> bool {
    let (w_h, h_h) = haystack.dimensions();
    let (w_n, h_n) = needle.dimensions();

    if w_h < w_n || h_h < h_n { return false; }

    // --- CẤU HÌNH ĐỘ DỄ TÍNH ---

    // Color Tolerance: Tăng lên 80 (Rất cao)
    // Cho phép mũi tên màu trắng bị mờ xuống màu xám đậm vẫn nhận ra.
    let color_tolerance = 80;

    // Match Threshold: Giảm xuống 0.70 (70%)
    // Chỉ cần khớp 70% diện tích là được.
    let match_threshold = 0.70;

    let limit_x = w_h - w_n;
    let limit_y = h_h - h_n;

    // Quét qua haystack (Nhảy bước 2 pixel để tìm nhanh)
    for y in (0..=limit_y).step_by(2) {
        for x in (0..=limit_x).step_by(2) {
            if fuzzy_match(haystack, needle, x, y, color_tolerance, match_threshold) {
                return true;
            }
        }
    }
    false
}

fn fuzzy_match(haystack: &RgbaImage, needle: &RgbaImage, sx: u32, sy: u32, tol: i16, threshold: f32) -> bool {
    let (w, h) = needle.dimensions();
    let mut total_checked = 0;
    let mut matched_count = 0;

    // Quét từng pixel của mũi tên mẫu
    for y in 0..h {
        for x in 0..w {
            let p_n = needle.get_pixel(x, y);

            // Chỉ kiểm tra những điểm thực sự là mũi tên (Alpha > 50)
            if p_n[3] < 50 { continue; }

            total_checked += 1;
            let p_h = haystack.get_pixel(sx + x, sy + y);

            if pixel_diff(p_h, p_n) <= tol {
                matched_count += 1;
            }
        }
    }

    if total_checked == 0 { return true; }

    // Tính tỉ lệ khớp
    (matched_count as f32 / total_checked as f32) >= threshold
}

fn pixel_diff(p1: &image::Rgba<u8>, p2: &image::Rgba<u8>) -> i16 {
    let r = (p1[0] as i16 - p2[0] as i16).abs();
    let g = (p1[1] as i16 - p2[1] as i16).abs();
    let b = (p1[2] as i16 - p2[2] as i16).abs();

    // Dùng trung bình cộng thay vì max để dễ tính hơn với các điểm nhiễu
    (r + g + b) / 3
}
</file>

<file path="src/ui.rs">
// ... (Giữ nguyên các phần import ở đầu file)
use crate::config;
use crate::overlay;
use eframe::egui;
use std::sync::atomic::Ordering;
use crate::AUTO_TRANSLATE_ENABLED;
use crate::HOTKEYS_NEED_UPDATE;
use crate::BindingTarget;
use crate::IS_BINDING_MODE;
use crate::KEY_STATE_MASK;
use crate::VK_MIN;
use crate::VK_MAX;
use crate::BINDING_SLEEP_MS;
use crate::FONT_SIZE_MIN;
use crate::FONT_SIZE_MAX;
use crate::TTS_SPEED_MIN;
use crate::TTS_SPEED_MAX;
use crate::ARROW_CHECK_INTERVAL_MIN;
use crate::ARROW_CHECK_INTERVAL_MAX;
use crate::DEFAULT_ARROW_CHECK_INTERVAL;
use crate::SUCCESS_DISPLAY_DURATION_SECS;
use crate::WWM_TEXT_REGION_X_RATIO;
use crate::WWM_TEXT_REGION_Y_RATIO;
use crate::WWM_TEXT_REGION_W_RATIO;
use crate::WWM_TEXT_REGION_H_RATIO;
use crate::WWM_NAME_REGION_X_RATIO;
use crate::WWM_NAME_REGION_Y_RATIO;
use crate::WWM_NAME_REGION_W_RATIO;
use crate::WWM_NAME_REGION_H_RATIO;
use crate::WWM_ARROW_REGION_X_RATIO;
use crate::WWM_ARROW_REGION_Y_RATIO;
use crate::WWM_ARROW_REGION_W_RATIO;
use crate::WWM_ARROW_REGION_H_RATIO;
use crate::WWM_REGION_PADDING;
use crate::WWM_REGION_EXTRA_WIDTH;
use crate::WWM_REGION_EXTRA_HEIGHT;
use crate::APP_NAME;
use winapi::um::winuser::{
    GetSystemMetrics, SM_CXSCREEN, SM_CYSCREEN, FindWindowW, GetClientRect, ClientToScreen,
    MessageBoxW, MB_OK, MB_ICONWARNING, MB_TOPMOST, IsWindowVisible
};
use winapi::shared::windef::{RECT, POINT};
use std::ffi::OsStr;
use std::os::windows::ffi::OsStrExt;
use webbrowser;
use std::fs;
use rfd;

// ... (Giữ nguyên các hàm helper to_wide, get_game_bounds, show_alert, ReaderState, UiState...)
fn to_wide(s: &str) -> Vec<u16> {
    OsStr::new(s).encode_wide().chain(std::iter::once(0)).collect()
}

fn get_game_bounds(window_title: &str) -> Option<(i32, i32, u32, u32)> {
    unsafe {
        let wide_title = to_wide(window_title);
        let hwnd = FindWindowW(std::ptr::null(), wide_title.as_ptr());
        if hwnd.is_null() || IsWindowVisible(hwnd) == 0 { return None; }
        let mut rect: RECT = std::mem::zeroed();
        if GetClientRect(hwnd, &mut rect) == 0 { return None; }
        let mut point = POINT { x: 0, y: 0 };
        if ClientToScreen(hwnd, &mut point) == 0 { return None; }
        let width = (rect.right - rect.left) as u32;
        let height = (rect.bottom - rect.top) as u32;
        Some((point.x, point.y, width, height))
    }
}

fn show_alert(message: &str) {
    let msg = message.to_string();
    std::thread::spawn(move || {
        unsafe {
            let wide_msg = to_wide(&msg);
            let wide_title = to_wide("Thông báo");
            MessageBoxW(std::ptr::null_mut(), wide_msg.as_ptr(), wide_title.as_ptr(), MB_OK | MB_ICONWARNING | MB_TOPMOST);
        }
    });
}

#[derive(Clone)]
pub struct ReaderState {
    pub is_open: bool,
    pub raw_text: String,
    pub chunks: Vec<String>,
    pub current_index: usize,
    pub is_playing: bool,
    pub processing_audio: bool,
}

impl ReaderState {
    fn new() -> Self {
        Self { is_open: false, raw_text: String::new(), chunks: Vec::new(), current_index: 0, is_playing: false, processing_audio: false, }
    }
    pub fn parse_text(&mut self) {
        let text = self.raw_text.clone();
        let mut final_chunks = Vec::new();
        let mut current_sentence = String::new();
        let mut in_quote = false;
        for c in text.chars() {
            if c == '"' || c == '“' || c == '”' { in_quote = !in_quote; }
            current_sentence.push(c);
            if !in_quote && (c == '.' || c == '!' || c == '?' || c == '\n') {
                if !current_sentence.trim().is_empty() { final_chunks.push(current_sentence.trim().to_string()); current_sentence.clear(); }
            }
        }
        if !current_sentence.trim().is_empty() { final_chunks.push(current_sentence.trim().to_string()); }
        self.chunks = final_chunks;
        self.current_index = 0;
        self.is_playing = false;
    }
}

#[derive(Clone)]
pub struct UiState {
    pub show_popup: bool,
    pub popup_text: String,
    pub show_reset_confirm: bool,
    pub show_arrow_window: bool,
    pub show_arrow_help: bool,
    pub show_password: bool,
    pub reader: ReaderState,
}

#[derive(Clone)]
pub struct ConfigState {
    pub config: config::Config,
    pub gemini_api_key: String,
    pub current_prompt: String,
    pub editing_prompt_index: Option<usize>,
    pub selected_api: String,
    pub use_tts: bool,
}

#[derive(Clone)]
pub struct HotkeyState {
    pub hotkey_translate: String,
    pub hotkey_select: String,
    pub hotkey_instant: String,
    pub hotkey_auto: String,
    pub hotkey_toggle_auto: String,
}

#[derive(Clone)]
pub struct WwmState {
    pub wwm_success_timer: Option<std::time::Instant>,
    pub wwm_name_success_timer: Option<std::time::Instant>,
    pub arrow_wwm_success_timer: Option<std::time::Instant>,
    pub auto_translate_active: bool,
}

impl UiState {
    pub fn new() -> Self {
        Self { show_popup: false, popup_text: String::new(), show_reset_confirm: false, show_arrow_window: false, show_arrow_help: false, show_password: false, reader: ReaderState::new(), }
    }
}

impl ConfigState {
    pub fn new(config: config::Config) -> Self {
        Self { gemini_api_key: config.gemini_api_key.clone(), current_prompt: config.current_prompt.clone(), editing_prompt_index: None, selected_api: config.selected_api.clone(), use_tts: config.use_tts, config, }
    }
}

impl HotkeyState {
    pub fn new(config: &config::Config) -> Self {
        Self { hotkey_translate: config.hotkey_translate.clone(), hotkey_select: config.hotkey_select.clone(), hotkey_instant: config.hotkey_instant.clone(), hotkey_auto: config.hotkey_auto.clone(), hotkey_toggle_auto: config.hotkey_toggle_auto.clone(), }
    }
}

impl WwmState {
    pub fn new() -> Self {
        Self { wwm_success_timer: None, wwm_name_success_timer: None, arrow_wwm_success_timer: None, auto_translate_active: false, }
    }
}

pub trait UiRenderer {
    fn render_header(&mut self, ui: &mut egui::Ui);
    fn render_api_section(&mut self, ui: &mut egui::Ui);
    fn render_prompt_section(&mut self, ui: &mut egui::Ui);
    fn render_hotkeys_section(&mut self, ui: &mut egui::Ui);
    fn render_aux_regions_section(&mut self, ui: &mut egui::Ui);
    fn render_settings_section(&mut self, ui: &mut egui::Ui);
    fn render_wwm_section(&mut self, ctx: &egui::Context, ui: &mut egui::Ui);
    fn render_reader_window(&mut self, ctx: &egui::Context);
    fn sync_config_from_file(&mut self);
    fn check_key_binding(&mut self);
    fn load_texture(&mut self, ctx: &egui::Context, bytes: &[u8], is_arrow: bool);
}

impl UiRenderer for super::MainApp {
    fn render_header(&mut self, ui: &mut egui::Ui) {
        ui.vertical_centered(|ui| {
            ui.heading(egui::RichText::new(APP_NAME).strong().size(24.0));
        });
        ui.add_space(5.0);
        ui.horizontal(|ui| {
            let mut listening = !self.is_paused;
            if ui.checkbox(&mut listening, "✅ Nghe phím").changed() {
                self.is_paused = !listening;
                crate::LISTENING_PAUSED.store(self.is_paused, Ordering::Relaxed);
                if self.is_paused {
                    self.wwm_state.auto_translate_active = false;
                    AUTO_TRANSLATE_ENABLED.store(false, Ordering::Relaxed);
                }
            }
            if ui.button("🔽 Ẩn").clicked() {
                ui.ctx().send_viewport_cmd(egui::ViewportCommand::Visible(false));
            }
            ui.separator();
            if ui.button(egui::RichText::new("📖 Đọc văn bản").small().strong()).clicked() {
                 self.ui_state.reader.is_open = true;
            }
            let theme_text = if self.config_state.config.is_dark_mode { "🌗 Tối" } else { "🌗 Sáng" };
            if ui.button(egui::RichText::new(theme_text).small()).clicked() {
                self.config_state.config.is_dark_mode = !self.config_state.config.is_dark_mode;
                self.config_state.config.save().unwrap();
            }
            if ui.button(egui::RichText::new("🔄 Reset").small().color(egui::Color32::RED)).clicked() {
                self.ui_state.show_reset_confirm = true;
            }
            if ui.button(egui::RichText::new("👤 by Baolinh0305").small()).clicked() {
                  let _ = webbrowser::open("https://github.com/Baolinh0305/instant-screen-narrator/releases");
            }
        });
        ui.add_space(5.0);
    }

    fn render_api_section(&mut self, ui: &mut egui::Ui) {
        egui::CollapsingHeader::new(egui::RichText::new("🌐 Cấu hình API").strong()).default_open(true).show(ui, |ui| {
            egui::Grid::new("api_grid").num_columns(2).spacing([20.0, 15.0]).striped(true).show(ui, |ui| {
                ui.label("Dịch vụ:");
                ui.horizontal(|ui| {
                    egui::ComboBox::from_id_source("api_selector")
                        .selected_text(if self.config_state.selected_api == "gemini" { "Gemini (Không nên dùng)" } else { "Groq (Nhanh)" })
                        .width(200.0)
                        .show_ui(ui, |ui| {
                            if ui.selectable_value(&mut self.config_state.selected_api, "gemini".to_string(), "Gemini (Không nên dùng)").clicked() {
                                self.config_state.config.selected_api = self.config_state.selected_api.clone();
                                self.config_state.config.save().unwrap();
                            }
                            if ui.selectable_value(&mut self.config_state.selected_api, "groq".to_string(), "Groq (Meta Llama)").clicked() {
                                self.config_state.config.selected_api = self.config_state.selected_api.clone();
                                self.config_state.config.save().unwrap();
                            }
                        });

                    ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                        let help_text = if self.config_state.selected_api == "gemini" { "❓ Hướng dẫn (Gemini)" } else { "❓ Hướng dẫn (Groq)" };
                        if ui.add(egui::Button::new(egui::RichText::new(help_text).small())).clicked() {
                            self.ui_state.show_popup = true;
                            self.ui_state.popup_text = self.config_state.selected_api.clone();
                        }
                    });
                });
                ui.end_row();

                ui.label("API Key:");
                ui.vertical(|ui| {
                      let show_pass = self.ui_state.show_password;
                      if self.config_state.selected_api == "gemini" {
                          if ui.add(egui::TextEdit::singleline(&mut self.config_state.gemini_api_key).password(!show_pass).desired_width(250.0)).changed() {
                              self.config_state.config.gemini_api_key = self.config_state.gemini_api_key.clone();
                              self.config_state.config.save().unwrap();
                          }
                      } else {
                          if self.config_state.config.groq_api_keys.is_empty() {
                              self.config_state.config.groq_api_keys.push(String::new());
                          }
                          if let Some(key) = self.config_state.config.groq_api_keys.get_mut(0) {
                              if ui.add(egui::TextEdit::singleline(key).password(!show_pass).desired_width(250.0)).changed() {
                                  self.config_state.config.save().unwrap();
                              }
                          }
                      }
                      if ui.button(if self.ui_state.show_password { "🙈 Ẩn Key" } else { "👁 Hiện Key" }).clicked() {
                          self.ui_state.show_password = !self.ui_state.show_password;
                      }
                 });
                 ui.end_row();
            });
        });
    }

    fn render_prompt_section(&mut self, ui: &mut egui::Ui) {
        egui::CollapsingHeader::new(egui::RichText::new("📝 Cấu hình Dịch (Prompt)").strong()).default_open(true).show(ui, |ui| {
            ui.horizontal_wrapped(|ui| {
                if ui.button("🗡️ Kiếm hiệp").clicked() {
                    self.config_state.current_prompt = config::Config::get_wuxia_prompt();
                    self.config_state.config.current_prompt = self.config_state.current_prompt.clone();
                    self.config_state.editing_prompt_index = None;
                    self.config_state.config.save().unwrap();
                }
                if ui.button("🌍 Thông thường").clicked() {
                    self.config_state.current_prompt = config::Config::get_normal_prompt();
                    self.config_state.config.current_prompt = self.config_state.current_prompt.clone();
                    self.config_state.editing_prompt_index = None;
                    self.config_state.config.save().unwrap();
                }
                if ui.button("🔍 Phân tích hình ảnh").clicked() {
                    self.config_state.current_prompt = config::Config::get_analyze_prompt();
                    self.config_state.config.current_prompt = self.config_state.current_prompt.clone();
                    self.config_state.editing_prompt_index = None;
                    self.config_state.config.save().unwrap();
                }
                if ui.button("abc Xuất chữ").clicked() {
                    self.config_state.current_prompt = config::Config::get_extract_text_prompt();
                    self.config_state.config.current_prompt = self.config_state.current_prompt.clone();
                    self.config_state.editing_prompt_index = None;
                    self.config_state.config.save().unwrap();
                }
                let mut to_select = None;
                for (i, _) in self.config_state.config.saved_prompts.iter().enumerate() {
                    let btn_label = format!("Mẫu {}", i + 1);
                    let is_selected = self.config_state.editing_prompt_index == Some(i);
                    if ui.add(egui::Button::new(btn_label).selected(is_selected)).clicked() {
                        to_select = Some(i);
                    }
                }
                if let Some(i) = to_select {
                    self.config_state.editing_prompt_index = Some(i);
                    self.config_state.current_prompt = self.config_state.config.saved_prompts[i].content.clone();
                    self.config_state.config.current_prompt = self.config_state.current_prompt.clone();
                    self.config_state.config.save().unwrap();
                }
                if ui.button("➕").clicked() {
                    self.config_state.config.saved_prompts.push(config::CustomPrompt {
                        content: String::new(),
                    });
                    self.config_state.editing_prompt_index = Some(self.config_state.config.saved_prompts.len() - 1);
                    self.config_state.current_prompt = String::new();
                    self.config_state.config.save().unwrap();
                }
            });
            ui.add_space(5.0);
            if let Some(idx) = self.config_state.editing_prompt_index {
                if idx < self.config_state.config.saved_prompts.len() {
                    ui.horizontal(|ui| {
                        ui.label(egui::RichText::new(format!("Đang sửa: Mẫu {}", idx + 1)).italics());
                        ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                            if ui.add(egui::Button::new(egui::RichText::new("🗑").color(egui::Color32::RED))).clicked() {
                                self.config_state.config.saved_prompts.remove(idx);
                                self.config_state.editing_prompt_index = None;
                                self.config_state.current_prompt = config::Config::get_normal_prompt();
                                self.config_state.config.current_prompt = self.config_state.current_prompt.clone();
                                self.config_state.config.save().unwrap();
                            }
                        });
                    });
                }
            }
            if ui.add(egui::TextEdit::multiline(&mut self.config_state.current_prompt).desired_rows(4).desired_width(f32::INFINITY)).changed() {
                self.config_state.config.current_prompt = self.config_state.current_prompt.clone();
                self.config_state.config.save().unwrap();
                if let Some(idx) = self.config_state.editing_prompt_index {
                    if idx < self.config_state.config.saved_prompts.len() {
                        self.config_state.config.saved_prompts[idx].content = self.config_state.current_prompt.clone();
                        self.config_state.config.save().unwrap();
                    }
                }
            }
        });
    }

    fn render_hotkeys_section(&mut self, ui: &mut egui::Ui) {
        egui::CollapsingHeader::new(egui::RichText::new("⌨️ Phím tắt chung").strong()).default_open(true).show(ui, |ui| {
              egui::Grid::new("hotkey_grid").num_columns(2).spacing([20.0, 10.0]).striped(true).show(ui, |ui| {
                let mut draw_bind_btn = |label: &str, target: BindingTarget, current_key: &str| {
                      ui.label(label);
                      let btn_text = if self.binding_target == Some(target) { "🛑 Đang chờ phím..." } else { current_key };
                      let btn = if self.binding_target == Some(target) {
                          egui::Button::new(egui::RichText::new(btn_text).color(egui::Color32::YELLOW))
                      } else {
                          egui::Button::new(btn_text)
                      };
                      if ui.add(btn).clicked() {
                          if self.binding_target == Some(target) {
                              self.binding_target = None;
                              IS_BINDING_MODE.store(false, Ordering::Relaxed);
                          } else {
                              self.binding_target = Some(target);
                              IS_BINDING_MODE.store(true, Ordering::Relaxed);
                          }
                      }
                      ui.end_row();
                 };
                 draw_bind_btn("Dịch vùng đã chọn:", BindingTarget::Translate, &self.hotkey_state.hotkey_translate);
                 draw_bind_btn("Chọn vùng dịch:", BindingTarget::Select, &self.hotkey_state.hotkey_select);
                 draw_bind_btn("Chụp & Dịch ngay:", BindingTarget::Instant, &self.hotkey_state.hotkey_instant);
                 draw_bind_btn("Bật/Tắt Tự động dịch:", BindingTarget::ToggleAuto, &self.hotkey_state.hotkey_toggle_auto);
            });
        });
    }

    fn render_aux_regions_section(&mut self, ui: &mut egui::Ui) {
        egui::CollapsingHeader::new(egui::RichText::new("📑 Vùng dịch phụ (Multi-Region)").strong()).default_open(true).show(ui, |ui| {
            if ui.button("➕ Thêm vùng dịch mới").clicked() {
                let new_id = self.config_state.config.aux_regions.len();
                self.config_state.config.aux_regions.push(config::AuxRegion {
                    id: new_id,
                    name: format!("Vùng phụ #{}", new_id + 1),
                    region: None,
                    hotkey_select: "NONE".to_string(),
                    hotkey_translate: "NONE".to_string(),
                });
                self.config_state.config.save().unwrap();
                HOTKEYS_NEED_UPDATE.store(true, Ordering::Relaxed);
            }
            ui.add_space(5.0);
            let mut remove_idx = None;
            for (i, aux) in self.config_state.config.aux_regions.iter_mut().enumerate() {
                ui.group(|ui| {
                    ui.horizontal(|ui| {
                        ui.label(egui::RichText::new(&aux.name).strong());
                        ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                            if ui.button("🗑 Xóa").clicked() { remove_idx = Some(i); }
                        });
                    });
                    ui.horizontal(|ui| {
                        ui.label("Chọn:");
                        let btn_txt_sel = if self.binding_target == Some(BindingTarget::AuxSelect(i)) { "..." } else { &aux.hotkey_select };
                        if ui.button(btn_txt_sel).clicked() {
                            self.binding_target = Some(BindingTarget::AuxSelect(i));
                            IS_BINDING_MODE.store(true, Ordering::Relaxed);
                        }
                        ui.label("Dịch:");
                        let btn_txt_trans = if self.binding_target == Some(BindingTarget::AuxTranslate(i)) { "..." } else { &aux.hotkey_translate };
                        if ui.button(btn_txt_trans).clicked() {
                            self.binding_target = Some(BindingTarget::AuxTranslate(i));
                            IS_BINDING_MODE.store(true, Ordering::Relaxed);
                        }
                        if aux.region.is_some() { ui.label("✅ Đã có vùng"); } else { ui.label("⚠️ Chưa chọn vùng"); }
                    });
                });
                ui.add_space(2.0);
            }
            if let Some(i) = remove_idx {
                self.config_state.config.aux_regions.remove(i);
                self.config_state.config.save().unwrap();
                HOTKEYS_NEED_UPDATE.store(true, Ordering::Relaxed);
            }
        });
    }

    fn render_settings_section(&mut self, ui: &mut egui::Ui) {
        egui::CollapsingHeader::new(egui::RichText::new("⚙️ Cài đặt hiển thị & Âm thanh").strong()).default_open(true).show(ui, |ui| {
            egui::Grid::new("settings_grid").num_columns(2).spacing([20.0, 10.0]).show(ui, |ui| {
                ui.label("Overlay:");
                ui.vertical(|ui| {
                    if ui.add(egui::Checkbox::new(&mut self.config_state.config.show_overlay, "Hiện văn bản")).changed() {
                        self.config_state.config.save().unwrap();
                    }
                    ui.horizontal(|ui| {
                        ui.label("Cỡ chữ:");
                        if ui.add_enabled(self.config_state.config.show_overlay, egui::Slider::new(&mut self.config_state.config.overlay_font_size, FONT_SIZE_MIN as i32..=FONT_SIZE_MAX as i32).text("px")).changed() {
                            overlay::set_font_size(self.config_state.config.overlay_font_size);
                            self.config_state.config.save().unwrap();
                        }
                    });
                });
                ui.end_row();
                ui.label("TTS (Đọc):");
                ui.vertical(|ui| {
                    if ui.add(egui::Checkbox::new(&mut self.config_state.use_tts, "Bật đọc")).changed() {
                        self.config_state.config.use_tts = self.config_state.use_tts;
                        self.config_state.config.save().unwrap();
                    }
                    ui.horizontal(|ui| {
                        ui.label("Tốc độ:");
                        if ui.add_enabled(self.config_state.use_tts, egui::Slider::new(&mut self.config_state.config.speed, TTS_SPEED_MIN..=TTS_SPEED_MAX).text("x")).changed() {
                            self.config_state.config.save().unwrap();
                        }
                    });
                });
                ui.end_row();
                ui.label("Tùy chọn khác:");
                ui.vertical(|ui| {
                    if ui.add(egui::Checkbox::new(&mut self.config_state.config.freeze_screen, "Đóng băng khi chọn vùng")).changed() {
                        self.config_state.config.save().unwrap();
                    }
                });
                ui.end_row();
                ui.label("Copy Text:");
                ui.vertical(|ui| {
                    if ui.add(egui::Checkbox::new(&mut self.config_state.config.auto_copy, "Tự động Copy kết quả")).changed() {
                        self.config_state.config.save().unwrap();
                    }
                    if self.config_state.config.auto_copy {
                        ui.horizontal(|ui| {
                            ui.radio_value(&mut self.config_state.config.copy_original, false, "Copy bản dịch");
                            ui.radio_value(&mut self.config_state.config.copy_original, true, "Copy bản gốc");
                        });
                        if ui.add(egui::Checkbox::new(&mut self.config_state.config.copy_instant_only, "Chỉ áp dụng lên Dịch nhanh")).changed() {
                            self.config_state.config.save().unwrap();
                        }
                    }
                });
                ui.end_row();
            });
        });
    }

    fn render_wwm_section(&mut self, ctx: &egui::Context, ui: &mut egui::Ui) {
        ui.vertical_centered(|ui| {
            egui::CollapsingHeader::new(egui::RichText::new("🎮 Dịch Where Winds Meet").strong()).default_open(true).show(ui, |ui| {
                ui.add_space(5.0);
                ui.horizontal(|ui| {
                    ui.label("Phím tắt chọn vùng Mũi tên:");
                    let btn_text = if self.binding_target == Some(BindingTarget::Auto) { "🛑 Chờ..." } else { &self.hotkey_state.hotkey_auto };
                    let btn = if self.binding_target == Some(BindingTarget::Auto) { egui::Button::new(egui::RichText::new(btn_text).color(egui::Color32::YELLOW)) } else { egui::Button::new(btn_text) };
                    if ui.add(btn).clicked() {
                        if self.binding_target == Some(BindingTarget::Auto) { self.binding_target = None; IS_BINDING_MODE.store(false, Ordering::Relaxed); } else { self.binding_target = Some(BindingTarget::Auto); IS_BINDING_MODE.store(true, Ordering::Relaxed); }
                    }
                    ui.add_space(10.0);
                    if ui.button("❓").clicked() { self.ui_state.show_arrow_help = true; }
                });
                ui.add_space(5.0);
                ui.horizontal(|ui| {
                    ui.with_layout(egui::Layout::left_to_right(egui::Align::Center).with_main_align(egui::Align::Center), |ui| {
                        let mut wwm_text = "🎯 Tự động chọn vùng dịch WWM";
                        if let Some(time) = self.wwm_state.wwm_success_timer {
                            if time.elapsed().as_secs_f32() < SUCCESS_DISPLAY_DURATION_SECS { wwm_text = "✅ Đã chọn"; ctx.request_repaint(); }
                            else { self.wwm_state.wwm_success_timer = None; }
                        }
                        if ui.add(egui::Button::new(wwm_text)).clicked() {
                            if let Some((win_x, win_y, win_w, win_h)) = get_game_bounds("Where Winds Meet") {
                                let f_w = win_w as f32;
                                let f_h = win_h as f32;
                                let region = config::Region {
                                    x: win_x + (f_w * WWM_TEXT_REGION_X_RATIO) as i32 - WWM_REGION_PADDING,
                                    y: win_y + (f_h * WWM_TEXT_REGION_Y_RATIO) as i32 - WWM_REGION_PADDING,
                                    width: (f_w * WWM_TEXT_REGION_W_RATIO) as u32 + WWM_REGION_EXTRA_WIDTH,
                                    height: (f_h * WWM_TEXT_REGION_H_RATIO) as u32 + WWM_REGION_EXTRA_HEIGHT
                                };
                                self.config_state.config.fixed_regions.clear();
                                self.config_state.config.fixed_regions.push(region.clone());
                                self.config_state.current_prompt = config::Config::get_wuxia_prompt();
                                self.config_state.config.current_prompt = self.config_state.current_prompt.clone();
                                self.config_state.editing_prompt_index = None;
                                self.config_state.config.save().unwrap();
                                self.sync_config_from_file();
                                self.wwm_state.wwm_success_timer = Some(std::time::Instant::now());
                                overlay::show_highlight(RECT{left: region.x, top: region.y, right: region.x + region.width as i32, bottom: region.y + region.height as i32});
                            } else {
                                show_alert("Không tìm thấy cửa sổ 'Where Winds Meet'. Vui lòng mở game trước.");
                            }
                        }
                        ui.label(egui::RichText::new("(16:9)").italics().color(egui::Color32::GRAY));
                    });
                });
                ui.horizontal(|ui| {
                    ui.with_layout(egui::Layout::left_to_right(egui::Align::Center).with_main_align(egui::Align::Center), |ui| {
                        let mut wwm_name_text = "🎯 Tự chọn vùng dịch WWM (có tên người thoại)";
                        if let Some(time) = self.wwm_state.wwm_name_success_timer {
                            if time.elapsed().as_secs_f32() < SUCCESS_DISPLAY_DURATION_SECS { wwm_name_text = "✅ Đã chọn"; ctx.request_repaint(); }
                            else { self.wwm_state.wwm_name_success_timer = None; }
                        }
                        if ui.add(egui::Button::new(wwm_name_text)).clicked() {
                            if let Some((win_x, win_y, win_w, win_h)) = get_game_bounds("Where Winds Meet") {
                                let f_w = win_w as f32;
                                let f_h = win_h as f32;
                                let region = config::Region {
                                    x: win_x + (f_w * WWM_NAME_REGION_X_RATIO) as i32,
                                    y: win_y + (f_h * WWM_NAME_REGION_Y_RATIO) as i32,
                                    width: (f_w * WWM_NAME_REGION_W_RATIO) as u32,
                                    height: (f_h * WWM_NAME_REGION_H_RATIO) as u32
                                };
                                self.config_state.config.fixed_regions.clear();
                                self.config_state.config.fixed_regions.push(region.clone());
                                self.config_state.current_prompt = config::Config::get_wuxia_speaker_prompt();
                                self.config_state.config.current_prompt = self.config_state.current_prompt.clone();
                                self.config_state.editing_prompt_index = None;
                                self.config_state.config.save().unwrap();
                                self.sync_config_from_file();
                                self.wwm_state.wwm_name_success_timer = Some(std::time::Instant::now());
                                overlay::show_highlight(RECT{left: region.x, top: region.y, right: region.x + region.width as i32, bottom: region.y + region.height as i32});
                            } else {
                                show_alert("Không tìm thấy cửa sổ 'Where Winds Meet'.");
                            }
                        }
                        ui.label(egui::RichText::new("(16:9)").italics().color(egui::Color32::GRAY));
                    });
                });
                ui.horizontal(|ui| {
                    ui.with_layout(egui::Layout::left_to_right(egui::Align::Center).with_main_align(egui::Align::Center), |ui| {
                        let mut arrow_text = "🏹 Tự động chọn vùng Mũi tên WWM";
                        if let Some(time) = self.wwm_state.arrow_wwm_success_timer {
                            if time.elapsed().as_secs_f32() < SUCCESS_DISPLAY_DURATION_SECS { arrow_text = "✅ Đã chọn"; ctx.request_repaint(); }
                            else { self.wwm_state.arrow_wwm_success_timer = None; }
                        }
                        if ui.add(egui::Button::new(arrow_text)).clicked() {
                            if let Some((win_x, win_y, win_w, win_h)) = get_game_bounds("Where Winds Meet") {
                                let f_w = win_w as f32;
                                let f_h = win_h as f32;
                                let region = config::Region {
                                    x: win_x + (f_w * WWM_ARROW_REGION_X_RATIO) as i32,
                                    y: win_y + (f_h * WWM_ARROW_REGION_Y_RATIO) as i32,
                                    width: (f_w * WWM_ARROW_REGION_W_RATIO) as u32,
                                    height: (f_h * WWM_ARROW_REGION_H_RATIO) as u32
                                };
                                self.config_state.config.arrow_region = Some(region.clone());
                                self.config_state.config.save().unwrap();
                                self.sync_config_from_file();
                                self.wwm_state.arrow_wwm_success_timer = Some(std::time::Instant::now());
                                overlay::show_highlight(RECT{left: region.x, top: region.y, right: region.x + region.width as i32, bottom: region.y + region.height as i32});
                            } else {
                                show_alert("Không tìm thấy cửa sổ 'Where Winds Meet'.");
                            }
                        }
                        ui.label(egui::RichText::new("(16:9)").italics().color(egui::Color32::GRAY));
                        if ui.button("🖼️").clicked() { self.ui_state.show_arrow_window = true; }
                    });
                });

                // --- ĐÃ ẨN SLIDER TỐC ĐỘ MŨI TÊN TẠI ĐÂY ---

                ui.add_space(5.0);
                ui.horizontal(|ui| {
                    ui.with_layout(egui::Layout::left_to_right(egui::Align::Center).with_main_align(egui::Align::Center), |ui| {
                        let btn_text = if self.wwm_state.auto_translate_active { "🔄 ĐANG BẬT TỰ ĐỘNG DỊCH" } else { "🔄 Bật Tự Động Dịch" };
                        let btn_color = if self.wwm_state.auto_translate_active { egui::Color32::DARK_GREEN } else { egui::Color32::from_rgb(60, 60, 60) };
                        if ui.add(egui::Button::new(egui::RichText::new(btn_text).strong().color(egui::Color32::WHITE)).fill(btn_color).min_size(egui::vec2(200.0, 30.0))).clicked() {
                            self.wwm_state.auto_translate_active = !self.wwm_state.auto_translate_active;
                            AUTO_TRANSLATE_ENABLED.store(self.wwm_state.auto_translate_active, Ordering::Relaxed);
                            crate::show_toggle_notification(self.wwm_state.auto_translate_active);
                        }
                    });
                });
                ui.separator();
                ui.horizontal(|ui| {
                    ui.with_layout(egui::Layout::left_to_right(egui::Align::Center).with_main_align(egui::Align::Center), |ui| {
                        if ui.button("🐞 Debug Overlay").clicked() {
                            overlay::toggle_debug_overlay();
                        }
                        if ui.button("📂 Đổi ảnh mũi tên").clicked() {
                            if let Some(path) = rfd::FileDialog::new().add_filter("Image", &["png"]).pick_file() {
                                if let Ok(bytes) = fs::read(&path) {
                                    let dest = config::Config::get_custom_arrow_path();
                                    if let Ok(_) = fs::write(&dest, &bytes) {
                                        self.load_texture(ctx, &bytes, true);
                                    }
                                }
                            }
                        }
                        let custom_path = config::Config::get_custom_arrow_path();
                        if custom_path.exists() {
                            if ui.button("❌ Reset Mặc định").clicked() {
                                let _ = fs::remove_file(custom_path);
                                self.load_texture(ctx, crate::DEFAULT_ARROW, true);
                            }
                        }
                    });
                });
            });
        });
    }

    fn sync_config_from_file(&mut self) {
        let new_config = config::Config::load();
        self.config_state.config.fixed_regions = new_config.fixed_regions;
        self.config_state.config.arrow_region = new_config.arrow_region;
        self.config_state.config.instant_region = new_config.instant_region;
        self.config_state.config.aux_regions = new_config.aux_regions;
    }

    fn check_key_binding(&mut self) {
        if let Some(target) = self.binding_target {
            unsafe {
                for vk in VK_MIN..VK_MAX {
                    if (winapi::um::winuser::GetAsyncKeyState(vk) as u16 & KEY_STATE_MASK) != 0 {
                        if vk == winapi::um::winuser::VK_LBUTTON || vk == winapi::um::winuser::VK_RBUTTON || vk == winapi::um::winuser::VK_MBUTTON { continue; }
                        let key_name = crate::key_utils::get_name_from_vk(vk);
                        match target {
                            BindingTarget::Translate => { self.hotkey_state.hotkey_translate = key_name.clone(); self.config_state.config.hotkey_translate = key_name; }
                            BindingTarget::Select => { self.hotkey_state.hotkey_select = key_name.clone(); self.config_state.config.hotkey_select = key_name; }
                            BindingTarget::Instant => { self.hotkey_state.hotkey_instant = key_name.clone(); self.config_state.config.hotkey_instant = key_name; }
                            BindingTarget::Auto => { self.hotkey_state.hotkey_auto = key_name.clone(); self.config_state.config.hotkey_auto = key_name; }
                            BindingTarget::ToggleAuto => { self.hotkey_state.hotkey_toggle_auto = key_name.clone(); self.config_state.config.hotkey_toggle_auto = key_name; }
                            BindingTarget::AuxSelect(idx) => { if idx < self.config_state.config.aux_regions.len() { self.config_state.config.aux_regions[idx].hotkey_select = key_name; } }
                            BindingTarget::AuxTranslate(idx) => { if idx < self.config_state.config.aux_regions.len() { self.config_state.config.aux_regions[idx].hotkey_translate = key_name; } }
                        }
                        self.config_state.config.save().unwrap();
                        HOTKEYS_NEED_UPDATE.store(true, Ordering::Relaxed);
                        self.binding_target = None;
                        IS_BINDING_MODE.store(false, Ordering::Relaxed);
                        std::thread::sleep(std::time::Duration::from_millis(BINDING_SLEEP_MS));
                        break;
                    }
                }
            }
        }
    }

    fn render_reader_window(&mut self, ctx: &egui::Context) {
        if !self.ui_state.reader.is_open { return; }
        let mut open = true;
        egui::Window::new("Trình đọc văn bản (Text to Speech)").open(&mut open).resize(|r| r.fixed_size(egui::vec2(600.0, 700.0))).show(ctx, |ui| {
            ui.horizontal(|ui| {
                if ui.button("📂 Mở file Text").clicked() {
                    if let Some(path) = rfd::FileDialog::new().add_filter("Text", &["txt"]).pick_file() {
                         if let Ok(content) = std::fs::read_to_string(path) {
                             self.ui_state.reader.raw_text = content;
                             self.ui_state.reader.parse_text();
                         }
                    }
                }
                if ui.button("🧹 Xóa hết").clicked() {
                    self.ui_state.reader.raw_text.clear();
                    self.ui_state.reader.chunks.clear();
                    self.ui_state.reader.is_playing = false;
                    self.ui_state.reader.current_index = 0;
                }
            });
            ui.label("Nhập văn bản vào đây:");
            if ui.add(egui::TextEdit::multiline(&mut self.ui_state.reader.raw_text).desired_rows(5).desired_width(f32::INFINITY)).changed() {
                self.ui_state.reader.is_playing = false;
                self.ui_state.reader.parse_text();
            }
            ui.separator();
            ui.horizontal(|ui| {
                let icon_play = if self.ui_state.reader.is_playing { "⏸ Tạm dừng" } else { "▶ Đọc tiếp" };
                if ui.button(icon_play).clicked() {
                     self.ui_state.reader.is_playing = !self.ui_state.reader.is_playing;
                     if self.ui_state.reader.chunks.is_empty() { self.ui_state.reader.parse_text(); self.ui_state.reader.is_playing = true; }
                }
                if ui.button("⏹ Dừng lại").clicked() { self.ui_state.reader.is_playing = false; self.ui_state.reader.current_index = 0; }
                ui.label("Tốc độ:");
                ui.add(egui::Slider::new(&mut self.config_state.config.speed, 0.5..=2.0));
            });
            ui.separator();
            ui.label(egui::RichText::new("Danh sách câu (Nhấn vào để đọc từ câu đó):").strong());
            egui::ScrollArea::vertical().stick_to_bottom(true).max_height(400.0).show(ui, |ui| {
                for (i, chunk) in self.ui_state.reader.chunks.iter().enumerate() {
                    let is_active = i == self.ui_state.reader.current_index;
                    let text = format!("{}. {}", i + 1, chunk);
                    let label = egui::SelectableLabel::new(is_active, text);
                    if ui.add_sized([ui.available_width(), 0.0], label).clicked() {
                        self.ui_state.reader.current_index = i;
                        self.ui_state.reader.is_playing = true;
                        self.next_audio_buffer = None;
                        self.is_downloading_next = false;
                    }
                }
            });
        });
        self.ui_state.reader.is_open = open;
    }

    fn load_texture(&mut self, ctx: &egui::Context, bytes: &[u8], is_arrow: bool) {
        if let Ok(image) = image::load_from_memory(bytes) {
            let size = [image.width() as usize, image.height() as usize];
            let image_buffer = image.to_rgba8();
            let pixels = image_buffer.into_raw();
            let image_data = egui::ColorImage::from_rgba_unmultiplied(size, &pixels);
            let name = if is_arrow { "arrow_img" } else { "area_img" };
            let texture = ctx.load_texture(name, image_data, egui::TextureOptions::default());
            if is_arrow { self.arrow_texture = Some(texture); }
        }
    }
}
</file>

<file path="src/main.rs">
#![windows_subsystem = "windows"]

mod config;
mod capture;
mod translation;
mod tts;
mod overlay;
mod key_utils;
mod ui;

use crate::overlay::show_result_window;
use crate::ui::UiRenderer; 
use eframe::egui;
use std::sync::atomic::{AtomicBool, AtomicI32, Ordering};
use std::sync::atomic::AtomicU64;
use std::sync::mpsc::{self, Receiver, Sender};
use winapi::shared::windef::{RECT, HWND};
use winapi::shared::minwindef::UINT;
use winapi::um::winuser::*;
use winapi::um::libloaderapi::GetModuleHandleW;
use std::ffi::OsStr;
use std::os::windows::ffi::OsStrExt;
use image::{self, GenericImageView};
use std::fs;
use webbrowser;
use arboard::Clipboard;
use std::sync::Arc;
use std::time::Duration;

use tray_icon::{TrayIconBuilder, TrayIcon, TrayIconEvent, MouseButton};
use tray_icon::menu::{Menu, MenuItem, MenuEvent};

const DEFAULT_ARROW: &[u8] = include_bytes!("arrow.png");

// Constants
const APP_NAME: &str = "Instant Screen Narrator";
const THREAD_SLEEP_MS: u64 = 500;
const REPAINT_INTERVAL_MS: u64 = 250;
const SELECT_COOLDOWN_MS: u64 = 1000;
const BINDING_SLEEP_MS: u64 = 200;
const VK_MIN: i32 = 8;
const VK_MAX: i32 = 255;
const KEY_STATE_MASK: u16 = 0x8000;
const TIMER_INTERVAL_MS: u32 = 500;
const MISS_COUNTER_THRESHOLD: i32 = 5;
const SUCCESS_DISPLAY_DURATION_SECS: f32 = 1.0;
const CONFIG_SYNC_INTERVAL_SECS: u64 = 1;
const TTS_SPEED_MIN: f32 = 0.5;
const TTS_SPEED_MAX: f32 = 2.0;
const ARROW_CHECK_INTERVAL_MIN: f32 = 0.02;
const ARROW_CHECK_INTERVAL_MAX: f32 = 0.2;
const DEFAULT_ARROW_CHECK_INTERVAL: f32 = 0.02;
const FONT_SIZE_MIN: u32 = 10;
const FONT_SIZE_MAX: u32 = 72;
const PIXELS_PER_POINT: f32 = 1.2;

// WWM Region Ratios (16:9)
/* WWM Region Ratios (16:9) - Updated based on user coordinates
Region 1: Normal Text (423, 925) -> (1496, 1037)
W = 1496 - 423 = 1073
H = 1037 - 925 = 112 */
const WWM_TEXT_REGION_X_RATIO: f32 = 423.0 / 1920.0;
const WWM_TEXT_REGION_Y_RATIO: f32 = 925.0 / 1080.0;
const WWM_TEXT_REGION_W_RATIO: f32 = 1073.0 / 1920.0;
const WWM_TEXT_REGION_H_RATIO: f32 = 112.0 / 1080.0;

/* Region 2: With Name (423, 868) -> (1496, 1037)
W = 1496 - 423 = 1073
H = 1037 - 868 = 169 */
const WWM_NAME_REGION_X_RATIO: f32 = 423.0 / 1920.0;
const WWM_NAME_REGION_Y_RATIO: f32 = 868.0 / 1080.0;
const WWM_NAME_REGION_W_RATIO: f32 = 1073.0 / 1920.0;
const WWM_NAME_REGION_H_RATIO: f32 = 169.0 / 1080.0;

/* Region 3: Arrow (937, 1049) -> (979, 1079)
W = 979 - 937 = 42
H = 1079 - 1049 = 30 */
const WWM_ARROW_REGION_X_RATIO: f32 = 937.0 / 1920.0;
const WWM_ARROW_REGION_Y_RATIO: f32 = 1049.0 / 1080.0;
const WWM_ARROW_REGION_W_RATIO: f32 = 42.0 / 1920.0;
const WWM_ARROW_REGION_H_RATIO: f32 = 30.0 / 1080.0;

// Padding (Giữ nguyên hoặc chỉnh về 0 nếu muốn chính xác tuyệt đối theo tọa độ bạn đưa)
const WWM_REGION_PADDING: i32 = 0;
const WWM_REGION_EXTRA_WIDTH: u32 = 0;
const WWM_REGION_EXTRA_HEIGHT: u32 = 0;

static LAST_SELECT: AtomicU64 = AtomicU64::new(0);
static OVERLAY_ACTIVE: AtomicBool = AtomicBool::new(false);
static LISTENING_PAUSED: AtomicBool = AtomicBool::new(false);
static AUTO_TRANSLATE_ENABLED: AtomicBool = AtomicBool::new(false);
static GROQ_REMAINING: AtomicI32 = AtomicI32::new(-1);
static HOTKEYS_NEED_UPDATE: AtomicBool = AtomicBool::new(false);
static IS_BINDING_MODE: AtomicBool = AtomicBool::new(false);

fn to_wide(s: &str) -> Vec<u16> {
    OsStr::new(s).encode_wide().chain(std::iter::once(0)).collect()
}

fn force_show_window_at_position() {
    unsafe {
        let window_name = to_wide(APP_NAME);
        let hwnd = FindWindowW(std::ptr::null(), window_name.as_ptr());
        
        if !hwnd.is_null() {
            ShowWindow(hwnd, SW_RESTORE);
            SetForegroundWindow(hwnd);
            // ĐÃ XÓA ĐOẠN SetWindowPos GÂY LỖI KÉO DÀI CỬA SỔ
        }
    }
}

#[derive(Clone, Copy, PartialEq)]
pub enum BindingTarget {
    Translate,
    Select,
    Instant,
    Auto,
    ToggleAuto,
    AuxSelect(usize),
    AuxTranslate(usize),
}

enum AppSignal {
    Show,
}

// Cải tiến ReaderSignal để hỗ trợ Pre-load và Index Tracking
enum ReaderSignal {
    PlaybackFinished(usize),      // SỬA: Trả về index của câu vừa đọc xong
    DownloadFinished(Vec<u8>, usize), // Tải xong câu (data, index)
    Error,
}

pub struct MainApp {
    pub ui_state: ui::UiState,
    pub config_state: ui::ConfigState,
    pub hotkey_state: ui::HotkeyState,
    pub wwm_state: ui::WwmState,

    pub binding_target: Option<BindingTarget>,
    pub is_paused: bool,
    pub listener_spawned: bool,
    pub arrow_texture: Option<egui::TextureHandle>,
    pub last_config_sync: std::time::Instant,

    pub reader_rx: Receiver<ReaderSignal>,
    pub reader_tx: Sender<ReaderSignal>,
    
    // --- State cho Reader ---
    pub next_audio_buffer: Option<(Vec<u8>, usize)>, // SỬA: Lưu thêm index để kiểm tra
    pub is_downloading_next: bool,          
    pub is_playing_audio: bool,             

    _tray_icon: TrayIcon,
    rx_signal: Receiver<AppSignal>,
}

impl MainApp {
    fn new(cc: &eframe::CreationContext<'_>, tray_icon: TrayIcon, rx: Receiver<AppSignal>) -> Self {
        let mut config = config::Config::load();
        if config.groq_api_keys.is_empty() {
            config.groq_api_keys.push(String::new());
        }

        overlay::set_font_size(config.overlay_font_size);

        std::thread::spawn(|| {
            std::thread::sleep(Duration::from_millis(THREAD_SLEEP_MS));
            force_show_window_at_position();
        });

        let ctx_clone = cc.egui_ctx.clone();
        std::thread::spawn(move || {
            loop {
                std::thread::sleep(Duration::from_millis(REPAINT_INTERVAL_MS));
                ctx_clone.request_repaint();
            }
        });

        let (r_tx, r_rx) = std::sync::mpsc::channel();

        let mut app = Self {
            ui_state: ui::UiState::new(),
            config_state: ui::ConfigState::new(config.clone()),
            hotkey_state: ui::HotkeyState::new(&config),
            wwm_state: ui::WwmState::new(),
            binding_target: None,
            is_paused: false,
            listener_spawned: false,
            arrow_texture: None,
            last_config_sync: std::time::Instant::now(),

            reader_rx: r_rx,
            reader_tx: r_tx,
            next_audio_buffer: None,
            is_downloading_next: false,
            is_playing_audio: false,

            _tray_icon: tray_icon,
            rx_signal: rx,
        };

        app.start_service();
        app.listener_spawned = true;
        LISTENING_PAUSED.store(false, Ordering::Relaxed);

        app
    }

    fn configure_style(&self, ctx: &egui::Context) {
        if self.config_state.config.is_dark_mode {
            ctx.set_visuals(egui::Visuals::dark());
        } else {
            ctx.set_visuals(egui::Visuals::light());
        }

        let mut style = (*ctx.style()).clone();
        style.spacing.item_spacing = egui::vec2(6.0, 6.0);

        // --- THAY ĐỔI Ở ĐÂY: Chỉnh margin dưới về 0 ---
        style.spacing.window_margin = egui::Margin {
            left: 8.0,
            right: 8.0,
            top: 8.0,
            bottom: 0.0, // Để sát cạnh dưới
        };

        style.visuals.widgets.noninteractive.rounding = egui::Rounding::same(4.0);
        style.visuals.widgets.inactive.rounding = egui::Rounding::same(4.0);
        style.visuals.widgets.hovered.rounding = egui::Rounding::same(4.0);
        style.visuals.widgets.active.rounding = egui::Rounding::same(4.0);

        let border_color = egui::Color32::from_rgb(100, 149, 237);
        style.visuals.widgets.inactive.bg_stroke = egui::Stroke::new(1.0, border_color);
        style.visuals.widgets.hovered.bg_stroke = egui::Stroke::new(1.5, border_color);
        style.visuals.widgets.active.bg_stroke = egui::Stroke::new(2.0, border_color);
        ctx.set_style(style);
    }

    fn copy_to_clipboard(text: &str) {
        if let Ok(mut clipboard) = Clipboard::new() {
            let _ = clipboard.set_text(text);
        }
    }

    async fn translate_regions(
        mut config: config::Config,
        regions: Vec<config::Region>,
        tx: Sender<(String, bool, f32, bool)>,
        should_copy: bool,
    ) {
        // 1. Chuẩn bị Prompt
        let mut final_prompt = config.current_prompt.clone();
        
        // Nếu bật "Copy bản gốc", ta ép buộc LLM trả về format dạng: <Original> ||||| <Translation>
        // Điều này cho phép ta lấy được text gốc để copy và text dịch để đọc chỉ trong 1 request.
        let use_split_mode = should_copy && config.copy_original;
        
        if use_split_mode {
            final_prompt = format!("{}\n\nSPECIAL INSTRUCTION: You must output the result in two parts. Part 1 is the raw original text extracted from the image. Part 2 is the result of the prompt above. Separate them with the delimiter '|||||'. Do not add any other text. Format: [Original Text] ||||| [Result Text]", final_prompt);
        }

        let mut final_text_to_show = String::new(); // Dùng để hiển thị/đọc
        let mut final_text_to_copy = String::new(); // Dùng để copy (nếu split mode)
        
        overlay::set_font_size(config.overlay_font_size);

        for region in &regions {
            let image_bytes = capture::capture_image(region).unwrap_or_default();
            if !image_bytes.is_empty() {
                let mut attempts = 0;
                let max_attempts = if config.selected_api == "groq" { config.groq_api_keys.len() } else { 1 };
                let mut success = false;

                while attempts < max_attempts {
                    let api_key = if config.selected_api == "gemini" {
                        config.gemini_api_key.clone()
                    } else {
                        config.get_current_groq_key()
                    };

                    if api_key.is_empty() {
                        final_text_to_show.push_str("(Chưa nhập Key) ");
                        break;
                    }

                    // Gọi API với prompt đã chỉnh sửa
                    match translation::translate_from_image(&config.selected_api, &api_key, &final_prompt, &image_bytes).await {
                        Ok(result) => {
                            // Xử lý kết quả trả về
                            if use_split_mode {
                                let parts: Vec<&str> = result.text.split("|||||").collect();
                                if parts.len() >= 2 {
                                    final_text_to_copy.push_str(parts[0].trim());
                                    final_text_to_show.push_str(parts[1].trim());
                                } else {
                                    // Fallback nếu LLM không tuân thủ format (hiếm khi xảy ra)
                                    final_text_to_copy.push_str(&result.text);
                                    final_text_to_show.push_str(&result.text);
                                }
                                final_text_to_copy.push(' ');
                            } else {
                                final_text_to_show.push_str(&result.text);
                            }

                            if let Some(rem) = result.remaining_requests {
                                GROQ_REMAINING.store(rem, Ordering::Relaxed);
                            }
                            success = true;
                            break;
                        },
                        Err(translation::TranslationError::RateLimitExceeded) => {
                            if config.selected_api == "groq" && config.groq_api_keys.len() > 1 {
                                config.active_groq_index = (config.active_groq_index + 1) % config.groq_api_keys.len();
                                attempts += 1;
                                continue;
                            } else {
                                final_text_to_show.push_str("(Hết lượt Request & hết Key dự phòng) ");
                                break;
                            }
                        },
                        Err(translation::TranslationError::Other(e)) => {
                            let error_msg = format!("Lỗi: {} ", e);
                            final_text_to_show.push_str(&error_msg);
                            break;
                        }
                    }
                }
                if !success && final_text_to_show.is_empty() { final_text_to_show.push_str("... "); }
                final_text_to_show.push(' ');
            }
        }

        let cleaned_show = final_text_to_show.trim().to_string();
        let cleaned_copy = final_text_to_copy.trim().to_string();

        if !cleaned_show.is_empty() {
            if should_copy {
                if config.copy_original && !cleaned_copy.is_empty() {
                    Self::copy_to_clipboard(&cleaned_copy);
                } else {
                    Self::copy_to_clipboard(&cleaned_show);
                }
            }

            let _ = tx.send((cleaned_show.clone(), config.split_tts, config.speed, config.use_tts));
            if config.show_overlay {
                if let Some(region) = regions.first() {
                    let rect = RECT { left: region.x, top: region.y, right: region.x + region.width as i32, bottom: region.y + region.height as i32 };
                    let duration_ms = (cleaned_show.chars().count() as f32 / 10.0 * 1000.0) as u32;
                    let text_final = cleaned_show.clone();
                    std::thread::spawn(move || {
                        // Nếu không update được (do không phải mode auto/không có loading), thì hiện cửa sổ mới
                        if !overlay::update_loading_window(text_final.clone()) {
                             overlay::show_result_window(rect, text_final, duration_ms);
                        }
                    });
                }
            }
        }
    }

    // Helper: Tải audio cho một câu cụ thể (chạy trong thread)
    fn spawn_download(&self, text: String, index: usize) {
        let tx = self.reader_tx.clone();
        std::thread::spawn(move || {
            let rt = tokio::runtime::Runtime::new().unwrap();
            rt.block_on(async {
                match crate::tts::download_audio(text).await {
                    Ok(bytes) => { let _ = tx.send(ReaderSignal::DownloadFinished(bytes, index)); },
                    Err(_) => { let _ = tx.send(ReaderSignal::Error); }
                }
            });
        });
    }

    // Helper: Phát audio từ bytes (chạy trong thread)
    fn spawn_playback(&self, bytes: Vec<u8>, speed: f32, index: usize) { // SỬA: Nhận thêm index
        let tx = self.reader_tx.clone();
        std::thread::spawn(move || {
            if let Err(_) = crate::tts::play_audio_data(bytes, speed) {
                 let _ = tx.send(ReaderSignal::Error);
            }
            let _ = tx.send(ReaderSignal::PlaybackFinished(index)); // SỬA: Trả về index
        });
    }

    fn start_service(&mut self) {
        let (tx, rx) = std::sync::mpsc::channel::<(String, bool, f32, bool)>();

        std::thread::spawn(move || {
            let rt = tokio::runtime::Runtime::new().unwrap();
            while let Ok((text, split_tts, speed, use_tts)) = rx.recv() {
                rt.block_on(async { if let Err(_e) = tts::speak(&text, split_tts, speed, use_tts).await {} });
            }
        });

        let tx_clone = tx.clone();
        let tx_auto = tx.clone();

        // Thread Auto Translate
        std::thread::spawn(move || {
            let rt = tokio::runtime::Runtime::new().unwrap();
            let load_arrow = || -> Vec<u8> {
                let custom_path = config::Config::get_custom_arrow_path();
                if custom_path.exists() { if let Ok(b) = fs::read(custom_path) { return b; } }
                DEFAULT_ARROW.to_vec()
            };
            let arrow_bytes = load_arrow();
            let mut last_found_state = false;
            let mut miss_counter = 0;

            loop {
                let config = config::Config::load();
                let check_interval = config.arrow_check_interval;
                let enabled = AUTO_TRANSLATE_ENABLED.load(Ordering::Relaxed);
                
                if !enabled || arrow_bytes.is_empty() {
                    std::thread::sleep(std::time::Duration::from_millis(THREAD_SLEEP_MS));
                    continue;
                }

                if let Some(arrow_region) = &config.arrow_region {
                    let found = capture::is_template_present(arrow_region, &arrow_bytes);

                    // --- THÊM DÒNG NÀY ĐỂ CẬP NHẬT TRẠNG THÁI DEBUG ---
                    crate::overlay::ARROW_DEBUG_STATE.store(found, Ordering::Relaxed);
                    // --------------------------------------------------

                    if found {
                        miss_counter = 0;
                        if !last_found_state {
                            // --- SỬA Ở ĐÂY: Hiện Loading Overlay ngay lập tức ---
                            if config.show_overlay {
                                if let Some(target_region) = config.fixed_regions.first() {
                                    let rect = RECT {
                                        left: target_region.x,
                                        top: target_region.y,
                                        right: target_region.x + target_region.width as i32,
                                        bottom: target_region.y + target_region.height as i32
                                    };
                                    // Hiện cửa sổ loading "..."
                                    std::thread::spawn(move || { overlay::show_loading_window(rect); });
                                }
                            }
                            // ----------------------------------------------------

                            let tx_inner = tx_auto.clone();
                            let should_copy = config.auto_copy && !config.copy_instant_only;
                            rt.block_on(async { Self::translate_regions(config.clone(), config.fixed_regions.clone(), tx_inner, should_copy).await; });
                            last_found_state = true;
                        }
                    } else {
                        if last_found_state {
                            miss_counter += 1;
                            if miss_counter > MISS_COUNTER_THRESHOLD { last_found_state = false; miss_counter = 0; }
                        }
                    }
                }
                std::thread::sleep(std::time::Duration::from_secs_f32(check_interval)); 
            }
        });

        // --- WINDOWS HOTKEY LISTENER THREAD ---
        std::thread::spawn(move || {
            unsafe {
                let instance = GetModuleHandleW(std::ptr::null());
                let class_name = to_wide("HotkeyListener");
                let wc = WNDCLASSW {
                    lpfnWndProc: Some(DefWindowProcW),
                    hInstance: instance,
                    lpszClassName: class_name.as_ptr(),
                    ..std::mem::zeroed()
                };
                RegisterClassW(&wc);
                let hwnd = CreateWindowExW(0, class_name.as_ptr(), to_wide("Listener").as_ptr(), 0, 0, 0, 0, 0, std::ptr::null_mut(), std::ptr::null_mut(), instance, std::ptr::null_mut());

                let register_keys = |hwnd: HWND| {
                    let cfg = config::Config::load();
                    // Reset all
                    for i in 1..500 { UnregisterHotKey(hwnd, i); }

                    let k1 = crate::key_utils::get_vk_from_name(&cfg.hotkey_translate);
                    let k2 = crate::key_utils::get_vk_from_name(&cfg.hotkey_select);
                    let k3 = crate::key_utils::get_vk_from_name(&cfg.hotkey_instant);
                    let k4 = crate::key_utils::get_vk_from_name(&cfg.hotkey_auto);
                    let k5 = crate::key_utils::get_vk_from_name(&cfg.hotkey_toggle_auto);
                    if k1 > 0 { RegisterHotKey(hwnd, 1, 0, k1 as UINT); }
                    if k2 > 0 { RegisterHotKey(hwnd, 2, 0, k2 as UINT); }
                    if k3 > 0 { RegisterHotKey(hwnd, 3, 0, k3 as UINT); }
                    if k4 > 0 { RegisterHotKey(hwnd, 4, 0, k4 as UINT); }
                    if k5 > 0 { RegisterHotKey(hwnd, 5, 0, k5 as UINT); }

                    // --- AUX REGIONS KEYS ---
                    for (i, aux) in cfg.aux_regions.iter().enumerate() {
                        let k_sel = crate::key_utils::get_vk_from_name(&aux.hotkey_select);
                        let k_trans = crate::key_utils::get_vk_from_name(&aux.hotkey_translate);
                        if k_sel > 0 { RegisterHotKey(hwnd, 100 + i as i32, 0, k_sel as UINT); }
                        if k_trans > 0 { RegisterHotKey(hwnd, 200 + i as i32, 0, k_trans as UINT); }
                    }
                };

                register_keys(hwnd);
                SetTimer(hwnd, 1, TIMER_INTERVAL_MS, None);

                let mut msg: MSG = std::mem::zeroed();
                while GetMessageW(&mut msg, std::ptr::null_mut(), 0, 0) != 0 {
                    if msg.message == WM_TIMER {
                        if HOTKEYS_NEED_UPDATE.load(Ordering::Relaxed) {
                            register_keys(hwnd);
                            HOTKEYS_NEED_UPDATE.store(false, Ordering::Relaxed);
                        }
                    } else if msg.message == WM_HOTKEY {
                        if !LISTENING_PAUSED.load(Ordering::Relaxed) {
                            let id = msg.wParam as i32;
                            let config = config::Config::load();
                            
                            // --- MAIN KEYS ---
                            if id == 1 { // Translate
                                let tx = tx_clone.clone();
                                let rt = tokio::runtime::Runtime::new().unwrap();
                                let should_copy = config.auto_copy && !config.copy_instant_only;
                                std::thread::spawn(move || { rt.block_on(async { Self::translate_regions(config.clone(), config.fixed_regions.clone(), tx, should_copy).await; }); });
                            } else if id == 2 { // Select
                                if !OVERLAY_ACTIVE.load(Ordering::Relaxed) {
                                    let now = std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_millis() as u64;
                                    if now - LAST_SELECT.load(Ordering::Relaxed) > SELECT_COOLDOWN_MS {
                                        LAST_SELECT.store(now, Ordering::Relaxed); OVERLAY_ACTIVE.store(true, Ordering::Relaxed);
                                        overlay::set_selection_mode(0); std::thread::spawn(|| { overlay::show_selection_overlay(); OVERLAY_ACTIVE.store(false, Ordering::Relaxed); });
                                    }
                                }
                            } else if id == 3 { // Instant
                                if !OVERLAY_ACTIVE.load(Ordering::Relaxed) {
                                    OVERLAY_ACTIVE.store(true, Ordering::Relaxed); let tx = tx_clone.clone();
                                    overlay::set_selection_mode(2);
                                    std::thread::spawn(move || {
                                        overlay::show_selection_overlay(); OVERLAY_ACTIVE.store(false, Ordering::Relaxed);
                                        let config = config::Config::load();
                                        if let Some(region) = config.instant_region.clone() {
                                            let rt = tokio::runtime::Runtime::new().unwrap();
                                            let should_copy = config.auto_copy;
                                            rt.block_on(async { Self::translate_regions(config, vec![region], tx, should_copy).await; });
                                        }
                                    });
                                }
                            } else if id == 4 { // Auto
                                if !OVERLAY_ACTIVE.load(Ordering::Relaxed) {
                                    let now = std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_millis() as u64;
                                    if now - LAST_SELECT.load(Ordering::Relaxed) > SELECT_COOLDOWN_MS {
                                        LAST_SELECT.store(now, Ordering::Relaxed); OVERLAY_ACTIVE.store(true, Ordering::Relaxed);
                                        overlay::set_selection_mode(1); std::thread::spawn(|| { overlay::show_selection_overlay(); OVERLAY_ACTIVE.store(false, Ordering::Relaxed); });
                                    }
                                }
                            } else if id == 5 { // Toggle Auto
                                let current_state = AUTO_TRANSLATE_ENABLED.load(Ordering::Relaxed);
                                let new_state = !current_state;
                                AUTO_TRANSLATE_ENABLED.store(new_state, Ordering::Relaxed);
                                // Gọi hàm thông báo
                                show_toggle_notification(new_state);
                            }
                            // --- AUX REGIONS KEYS ---
                            else if id >= 100 && id < 200 { // Select Aux
                                let idx = (id - 100) as usize;
                                if !OVERLAY_ACTIVE.load(Ordering::Relaxed) {
                                    OVERLAY_ACTIVE.store(true, Ordering::Relaxed);
                                    overlay::set_selection_mode((100 + idx) as u8);
                                    std::thread::spawn(|| { overlay::show_selection_overlay(); OVERLAY_ACTIVE.store(false, Ordering::Relaxed); });
                                }
                            } else if id >= 200 && id < 300 { // Translate Aux
                                let idx = (id - 200) as usize;
                                if idx < config.aux_regions.len() {
                                    if let Some(region) = &config.aux_regions[idx].region {
                                        let tx = tx_clone.clone();
                                        let rt = tokio::runtime::Runtime::new().unwrap();
                                        let should_copy = config.auto_copy && !config.copy_instant_only;
                                        let reg_clone = region.clone();
                                        std::thread::spawn(move || { rt.block_on(async { Self::translate_regions(config.clone(), vec![reg_clone], tx, should_copy).await; }); });
                                    }
                                }
                            }
                        }
                    }
                    TranslateMessage(&msg); DispatchMessageW(&msg);
                }
            }
        });
    }
}

impl eframe::App for MainApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        while let Ok(signal) = self.rx_signal.try_recv() {
            match signal {
                AppSignal::Show => {
                    ctx.send_viewport_cmd(egui::ViewportCommand::Visible(true));
                    ctx.send_viewport_cmd(egui::ViewportCommand::Focus);
                    ctx.send_viewport_cmd(egui::ViewportCommand::Minimized(false));
                }
            }
        }

        // --- READER LOGIC (QUEUEING & PREFETCH) ---
        // SỬA: Kiểm tra buffer có đúng là buffer của câu hiện tại không
        let current_idx = self.ui_state.reader.current_index;
        let has_buffer_for_current = self.next_audio_buffer.as_ref().map_or(false, |(_, i)| *i == current_idx);

        if self.ui_state.reader.is_open && self.ui_state.reader.is_playing && !self.is_playing_audio && !self.ui_state.reader.chunks.is_empty() {
             if has_buffer_for_current {
                 // Có buffer ĐÚNG của câu hiện tại -> Phát ngay
                 if let Some((bytes, _)) = self.next_audio_buffer.take() {
                     let speed = self.config_state.config.speed;
                     self.spawn_playback(bytes, speed, current_idx);
                     self.is_playing_audio = true;
                     self.is_downloading_next = false;
                     // Trigger pre-fetch câu tiếp theo
                     if current_idx + 1 < self.ui_state.reader.chunks.len() {
                         let next_text = self.ui_state.reader.chunks[current_idx + 1].clone();
                         self.spawn_download(next_text, current_idx + 1);
                         self.is_downloading_next = true;
                     }
                 }
             } else if !self.is_downloading_next {
                 // Buffer rỗng hoặc sai index (do seek hoặc pause lâu) -> Tải câu hiện tại
                 // Chỉ tải nếu chưa có tiến trình tải nào đang chạy
                 if current_idx < self.ui_state.reader.chunks.len() {
                     let text = self.ui_state.reader.chunks[current_idx].clone();
                     self.spawn_download(text, current_idx);
                     self.is_downloading_next = true;
                 }
             }
        }

        // 2. Xử lý signals từ thread âm thanh
        while let Ok(sig) = self.reader_rx.try_recv() {
            match sig {
                ReaderSignal::DownloadFinished(bytes, index) => {
                    // Nếu dữ liệu tải về là của câu hiện tại (đang cần phát)
                    if index == self.ui_state.reader.current_index && !self.is_playing_audio {
                        // Phát ngay
                        let speed = self.config_state.config.speed;
                        self.spawn_playback(bytes, speed, index);
                        self.is_playing_audio = true;
                        self.is_downloading_next = false;
                        // Tải trước câu tiếp theo
                        if self.ui_state.reader.current_index + 1 < self.ui_state.reader.chunks.len() {
                             let next_text = self.ui_state.reader.chunks[self.ui_state.reader.current_index + 1].clone();
                             self.spawn_download(next_text, self.ui_state.reader.current_index + 1);
                             self.is_downloading_next = true;
                        }
                    } 
                    // Nếu dữ liệu tải về là của câu tiếp theo (Pre-fetch)
                    else if index == self.ui_state.reader.current_index + 1 {
                        self.next_audio_buffer = Some((bytes, index));
                        self.is_downloading_next = false;
                    }
                    // Nếu index không khớp (do người dùng click nhảy câu khác), ta bỏ qua dữ liệu này
                },
                ReaderSignal::PlaybackFinished(finished_index) => {
                    self.is_playing_audio = false;

                    // SỬA: Chỉ tự động chuyển câu nếu câu vừa đọc xong TRÙNG với câu hiện tại
                    // Nếu không trùng (do người dùng click câu khác), thì không được nhảy số.
                    if self.ui_state.reader.is_playing && finished_index == self.ui_state.reader.current_index {
                         self.ui_state.reader.current_index += 1;
                         
                         if self.ui_state.reader.current_index >= self.ui_state.reader.chunks.len() {
                             self.ui_state.reader.is_playing = false;
                             self.ui_state.reader.current_index = 0;
                             self.next_audio_buffer = None;
                         } 
                         // Reset cờ downloading để vòng lặp biết đường xử lý
                         self.is_downloading_next = false; 
                    }
                },
                ReaderSignal::Error => {
                    self.ui_state.reader.is_playing = false;
                    self.is_playing_audio = false;
                    self.is_downloading_next = false;
                }
            }
        }

        // -------------------------

        let mut fonts = egui::FontDefinitions::default();
        fonts.font_data.insert("roboto".to_owned(), egui::FontData::from_static(include_bytes!("roboto.ttf")));
        fonts.families.get_mut(&egui::FontFamily::Proportional).unwrap().insert(0, "roboto".to_owned());
        fonts.families.get_mut(&egui::FontFamily::Monospace).unwrap().push("roboto".to_owned());
        ctx.set_fonts(fonts);
        ctx.set_pixels_per_point(PIXELS_PER_POINT);

        self.configure_style(ctx);

        if self.binding_target.is_some() {
            self.check_key_binding();
            ctx.request_repaint();
        }

        // SYNC UI: Đảm bảo nút "Bật Tự Động Dịch" hiển thị đúng theo biến Global
        // Nếu dùng phím tắt để tắt/bật thì nút trên giao diện phải đổi màu theo
        self.wwm_state.auto_translate_active = AUTO_TRANSLATE_ENABLED.load(Ordering::Relaxed);

        if self.last_config_sync.elapsed() > Duration::from_secs(CONFIG_SYNC_INTERVAL_SECS) {
            self.sync_config_from_file();
            self.last_config_sync = std::time::Instant::now();
        }

        if self.arrow_texture.is_none() {
              let custom_path = config::Config::get_custom_arrow_path();
              if custom_path.exists() { if let Ok(b) = fs::read(custom_path) { self.load_texture(ctx, &b, true); } }
              else { self.load_texture(ctx, DEFAULT_ARROW, true); }
        }

        // --- LAYOUT CHIA 2 CỘT ---
        egui::CentralPanel::default().show(ctx, |ui| {
            self.render_header(ui);
            
            ui.separator();

            egui::ScrollArea::vertical().show(ui, |ui| {
                ui.columns(2, |columns| {
                    // Cột trái
                    columns[0].vertical(|ui| {
                        self.render_api_section(ui);
                        ui.add_space(10.0);
                        
                        self.render_prompt_section(ui);
                        ui.add_space(10.0);
                        
                        self.render_settings_section(ui);
                    });

                    // Cột phải
                    columns[1].vertical(|ui| {
                        self.render_hotkeys_section(ui);
                        ui.add_space(10.0);
                        
                        self.render_aux_regions_section(ui);
                        ui.add_space(10.0);
                        
                        self.render_wwm_section(ctx, ui);
                    });
                });
            });
        });

        self.render_reader_window(ctx);

        if self.ui_state.show_popup {
            let mut open = true;
            let title = if self.ui_state.popup_text == "gemini" { "Hướng dẫn Gemini" } else { "Hướng dẫn Groq" };
            egui::Window::new(title).collapsible(false).resizable(false).open(&mut open).show(ctx, |ui| {
                ui.spacing_mut().item_spacing = egui::vec2(10.0, 10.0);
                if self.ui_state.popup_text == "gemini" {
                    ui.heading("Gemini API");
                    ui.horizontal(|ui| { ui.label("1. Vào:"); ui.hyperlink("https://aistudio.google.com/api-keys"); });
                    ui.label("2. Đăng nhập Google -> Create API key"); ui.label("3. Copy key và dán vào tool");
                } else if self.ui_state.popup_text == "groq" {
                    ui.heading("Groq API (Nhanh)");
                    ui.horizontal(|ui| { ui.label("1. Vào:"); ui.hyperlink("https://console.groq.com/keys"); });
                    ui.label("2. Đăng nhập -> Create API Key"); ui.label("3. Copy key và dán vào tool");
                }
                ui.separator();
                ui.vertical_centered(|ui| { if ui.button("Đã hiểu").clicked() { self.ui_state.show_popup = false; } });
            });
            if !open { self.ui_state.show_popup = false; }
        }

        if self.ui_state.show_reset_confirm {
            let mut open = true;
            egui::Window::new("⚠️ Xác nhận Reset").collapsible(false).resizable(false).anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0)).open(&mut open).show(ctx, |ui| {
                ui.label("Bạn có muốn giữ lại API Key không?");
                ui.add_space(10.0);
                ui.horizontal(|ui| {
                    if ui.button("✅ Có (Giữ Key)").clicked() {
                        let saved_gemini = self.config_state.gemini_api_key.clone();
                        let saved_groq = self.config_state.config.groq_api_keys.clone();
                        self.config_state.config = config::Config::default();
                        self.config_state.config.gemini_api_key = saved_gemini;
                        self.config_state.config.groq_api_keys = saved_groq;

                        self.config_state.gemini_api_key = self.config_state.config.gemini_api_key.clone();
                        self.config_state.current_prompt = self.config_state.config.current_prompt.clone();
                        self.config_state.editing_prompt_index = None;
                        self.hotkey_state.hotkey_translate = self.config_state.config.hotkey_translate.clone();
                        self.hotkey_state.hotkey_select = self.config_state.config.hotkey_select.clone();
                        self.hotkey_state.hotkey_instant = self.config_state.config.hotkey_instant.clone();
                        self.hotkey_state.hotkey_auto = self.config_state.config.hotkey_auto.clone();
                        self.config_state.selected_api = self.config_state.config.selected_api.clone();
                        self.config_state.use_tts = self.config_state.config.use_tts;

                        overlay::set_font_size(self.config_state.config.overlay_font_size);
                        HOTKEYS_NEED_UPDATE.store(true, Ordering::Relaxed);
                        let _ = self.config_state.config.save();
                        self.ui_state.show_reset_confirm = false;
                    }
                    if ui.button("❌ Không (Xóa sạch)").clicked() {
                        self.config_state.config = config::Config::default();
                        self.config_state.gemini_api_key = String::new();
                        self.config_state.config.groq_api_keys = vec![String::new()];
                        self.config_state.current_prompt = self.config_state.config.current_prompt.clone();
                        self.config_state.editing_prompt_index = None;
                        self.hotkey_state.hotkey_translate = self.config_state.config.hotkey_translate.clone();
                        self.hotkey_state.hotkey_select = self.config_state.config.hotkey_select.clone();
                        self.hotkey_state.hotkey_instant = self.config_state.config.hotkey_instant.clone();
                        self.hotkey_state.hotkey_auto = self.config_state.config.hotkey_auto.clone();
                        self.config_state.selected_api = self.config_state.config.selected_api.clone();
                        self.config_state.use_tts = self.config_state.config.use_tts;

                        overlay::set_font_size(self.config_state.config.overlay_font_size);
                        HOTKEYS_NEED_UPDATE.store(true, Ordering::Relaxed);
                        let _ = self.config_state.config.save();
                        self.ui_state.show_reset_confirm = false;
                    }
                    if ui.button("🔙 Hủy").clicked() {
                        self.ui_state.show_reset_confirm = false;
                    }
                });
            });
            if !open { self.ui_state.show_reset_confirm = false; }
        }

        if self.ui_state.show_arrow_window {
            let mut open = true;
            egui::Window::new("Mũi tên hiện tại").open(&mut open).collapsible(false).resizable(true).default_size(egui::vec2(300.0, 300.0)).show(ctx, |ui| {
                  ui.label("Đây là hình ảnh mũi tên đang được dùng để nhận diện:");
                  ui.separator();
                if let Some(texture) = &self.arrow_texture {
                    let s = texture.size_vec2() * 2.0;
                    ui.centered_and_justified(|ui| { ui.image((texture.id(), s)); });
                } else { ui.label("Không tìm thấy arrow.png"); }
            });
            if !open { self.ui_state.show_arrow_window = false; }
        }

        if self.ui_state.show_arrow_help {
            let mut open = true;
            egui::Window::new("Giải thích Mũi tên").open(&mut open).collapsible(false).resizable(false).show(ctx, |ui| {
                ui.label("Đây là hình tam giác hiện ra ở dưới hội thoại mỗi khi nó hiện đầy đủ.");
                ui.label("Phần mềm sẽ dựa vào mũi tên đó để nhận biết khi nào câu thoại đã chạy xong và tiến hành tự động dịch.");
                ui.add_space(10.0);
                if ui.button("Đã hiểu").clicked() { self.ui_state.show_arrow_help = false; }
            });
            if !open { self.ui_state.show_arrow_help = false; }
        }
    }
}

fn main() -> Result<(), eframe::Error> {
    let mut options = eframe::NativeOptions::default();
    options.viewport.transparent = Some(false);

    // --- THAY ĐỔI Ở ĐÂY ---
    // Cũ: options.viewport.inner_size = Some(egui::vec2(900.0, 950.0));
    options.viewport.inner_size = Some(egui::vec2(850.0, 790.0));
    // ---------------------

    options.viewport.position = Some(egui::pos2(100.0, 100.0));

    let icon_bytes = include_bytes!("icon2.ico");
    if let Ok(icon_image) = image::load_from_memory(icon_bytes) {
        let icon_rgba = icon_image.to_rgba8();
        let icon_width = icon_image.width() as u32;
        let icon_height = icon_image.height() as u32;
        let icon_data = egui::IconData {
            rgba: icon_rgba.into_raw(),
            width: icon_width,
            height: icon_height,
        };
        options.viewport.icon = Some(Arc::new(icon_data.into()));
    }

    let tray_menu = Menu::new();
    let item_show = MenuItem::with_id("show", "Hiện ứng dụng / Cài đặt", true, None);
    let item_quit = MenuItem::with_id("quit", "Thoát hoàn toàn", true, None);
    let _ = tray_menu.append(&item_show);
    let _ = tray_menu.append(&item_quit);

    let (tx, rx) = mpsc::channel();

    let tray_icon_obj = if let Ok(image) = image::load_from_memory(icon_bytes) {
        let rgba = image.to_rgba8();
        let (width, height) = image.dimensions();
        if let Ok(icon) = tray_icon::Icon::from_rgba(rgba.into_raw(), width, height) {
             TrayIconBuilder::new()
            .with_menu(Box::new(tray_menu))
            .with_tooltip(APP_NAME)
            .with_icon(icon)
            .build()
            .ok()
        } else { None }
    } else { None };
    
    let tray_icon = tray_icon_obj.expect("Failed to create Tray Icon!");

    eframe::run_native(
        APP_NAME,
        options,
        Box::new(move |cc| {
            let ctx_clone = cc.egui_ctx.clone();
            let tx_clone = tx.clone();

            std::thread::spawn(move || {
                while let Ok(event) = TrayIconEvent::receiver().recv() {
                    if let TrayIconEvent::Click { button: MouseButton::Left, .. } = event {
                        force_show_window_at_position();
                        let _ = tx_clone.send(AppSignal::Show);
                        ctx_clone.request_repaint();
                    }
                }
            });

            let ctx_clone2 = cc.egui_ctx.clone();
            let tx_clone2 = tx.clone();

            std::thread::spawn(move || {
                while let Ok(event) = MenuEvent::receiver().recv() {
                    if event.id.as_ref() == "show" {
                        force_show_window_at_position();
                        let _ = tx_clone2.send(AppSignal::Show);
                        ctx_clone2.request_repaint();
                    } else if event.id.as_ref() == "quit" {
                        std::process::exit(0);
                    }
                }
            });

            Box::new(MainApp::new(cc, tray_icon, rx))
        }),
    )
}

// --- THÊM HÀM NÀY VÀO CUỐI FILE ---
pub fn show_toggle_notification(enabled: bool) {
    let text = if enabled { "Đã bật tự động dịch" } else { "Đã tắt tự động dịch" };
    
    // 1. Phát âm thanh (TTS)
    let text_audio = text.to_string();
    std::thread::spawn(move || {
        let rt = tokio::runtime::Runtime::new().unwrap();
        rt.block_on(async {
            let _ = crate::tts::speak(&text_audio, false, 1.2, true).await;
        });
    });

    // 2. Hiện thông báo trên màn hình
    let text_visual = text.to_string();
    std::thread::spawn(move || {
        unsafe {
            let screen_w = winapi::um::winuser::GetSystemMetrics(winapi::um::winuser::SM_CXSCREEN);
            let width = 400;
            let height = 100;
            let left = (screen_w / 2) - (width / 2);
            let top = 100;
            let rect = winapi::shared::windef::RECT {
                left,
                top,
                right: left + width,
                bottom: top + height
            };
            crate::overlay::show_result_window(rect, text_visual, 2000);
        }
    });
}
</file>

</files>
